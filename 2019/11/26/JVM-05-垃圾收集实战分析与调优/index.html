<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","width":300,"display":"post","offset":13,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1 垃圾收集实战             环境：Java HotSpot(TM) 64-Bit Server VM (25.211-b12)            1.1 Young GCYoung GC 模拟示例代码：">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-05-垃圾收集实战分析与调优">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;index.html">
<meta property="og:site_name" content="Westboy&#39;Blog">
<meta property="og:description" content="1 垃圾收集实战             环境：Java HotSpot(TM) 64-Bit Server VM (25.211-b12)            1.1 Young GCYoung GC 模拟示例代码：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;YoungGC示例分析1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;YoungGC示例分析2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;YoungGC示例分析3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;Metaspace元数据空间使用情况.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;模拟长期存活对象直接进入老年代3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;模拟长期存活对象直接进入老年代4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;模拟长期存活对象直接进入老年代1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;模拟长期存活对象直接进入老年代2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;模拟长期存活对象直接进入老年代5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;FullGC示例分析1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;FullGC示例分析2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;FullGC示例分析3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;FullGC示例分析4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;FullGC示例分析5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;jstat命令gc日志.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;jhat图1.png">
<meta property="og:updated_time" content="2019-11-26T08:58:20.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98&#x2F;YoungGC示例分析1.png">

<link rel="canonical" href="http://yoursite.com/2019/11/26/JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JVM-05-垃圾收集实战分析与调优 | Westboy'Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Westboy'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM-05-垃圾收集实战分析与调优
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 16:58:20" itemprop="dateCreated datePublished" datetime="2019-11-26T16:58:20+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-垃圾收集实战"><a href="#1-垃圾收集实战" class="headerlink" title="1 垃圾收集实战"></a>1 垃圾收集实战</h1><div class="note warning">
            <p>环境：Java HotSpot(TM) 64-Bit Server VM (25.211-b12) </p>
          </div><h2 id="1-1-Young-GC"><a href="#1-1-Young-GC" class="headerlink" title="1.1 Young GC"></a>1.1 Young GC</h2><p>Young GC 模拟示例代码：</p><a id="more"></a>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">5242880</span>                 <span class="comment">// 新生代大小 5242880B，即 5MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">5242880</span>              <span class="comment">// 新生代最大大小 5MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">10485760</span>        <span class="comment">// 初始堆大小 10MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">10485760</span>            <span class="comment">// 最大堆大小 10MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.log                      <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>执行示例代码后查看 gc.log 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JVM 信息</span></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (25.211-b12) for bsd-amd64 JRE (1.8.0_211-b12), built on Apr  1 2019 20:53:18 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内存信息</span></span><br><span class="line">Memory: 4k page, physical 16777216k(251828k free)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JVM 参数信息</span></span><br><span class="line">/proc/meminfo:</span><br><span class="line">CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GC 详细日志信息</span></span><br><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs] 3678K-&gt;329K(9728K), 0.0005871 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JVM 退出的时候打印出来的当前堆内存的使用情况</span></span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 4608K, used 2418K [0x00000007bf600000, 0x00000007bfb00000, 0x00000007bfb00000)</span><br><span class="line">  eden space 4096K,  51% used [0x00000007bf600000, 0x00000007bf80a558, 0x00000007bfa00000)</span><br><span class="line">  from space 512K,  64% used [0x00000007bfa80000, 0x00000007bfad2640, 0x00000007bfb00000)</span><br><span class="line">  to   space 512K,   0% used [0x00000007bfa00000, 0x00000007bfa00000, 0x00000007bfa80000)</span><br><span class="line"> concurrent mark-sweep generation total 5120K, used 0K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>对于上述日志从中能看来获取到哪些信息呢？接下来结合我们的示例代码一一进行分析。</p>
<p>其实从上面的日志注释中我们可以发现总的分为 5 块内容，对于我们来说最主要的就是<font color="red"> GC 详细日志信息</font>和<font color="red"> JVM 退出的时候打印出来的当前堆内存的使用情况</font>，接下来着重分析下这两块的内容。</p>
<p>首先看下 GC 详细日志信息内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs] 3678K-&gt;329K(9728K), 0.0005871 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p><font color="red">GC (Allocation Failure) 0.071</font>：当要分配内存空间时，Eden 区内存不够，即分配内存失败。0.071 表示的是 GC 发生的时间点，表示系统运行以后过了多少秒发生本次 GC。</p>
<p><font color="red">ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs</font>：通过 ParNew 就明白此次 GC 为新生代的 Young GC，4608K 表示新生代可用空间，即 4.5MB，3678K-&gt;329K 意思是对新生代执行一次 GC，GC 之前新生代占用空间大小为 3678K，GC 之后新生代占用空间大小 329K，表示本次 Young GC 有 329K 的对象存活下来。0.0015632 secs 表示本次 GC 耗时。</p>
<p>新生代可用空间 = Eden + 一个 Survivor = 4MB + 0.5MB = 4.5MB，然后当执行到示例代码第 7 行前，内存中的分布情况见下图：</p>
<img src="YoungGC示例分析1.png" width="450px">

<p>Eden 区中已占用三个 1MB 大小的数组，即为 3072KB，但是为什么从日志中显示 GC 前已使用的大小为 3678KB 呢？为什么会多出来的 0.5MB 呢？这是因为分配一个 1MB 数组时实际上 JVM 还会附带一些其他信息，每个数组实际占用大小是大于 1MB 的。</p>
<p>接着在执行示例代码中第 7 行时， Eden 分配一个 2MB 的数组，Eden 的可用空间是不够的，对象分配失败，触发 Young GC，然后 ParNew 执行垃圾回收，回收掉之前我们创建的三个数组，因为它们已经没有被引用了。GC 回收之后从 3678KB 内存使用降低到 329KB，也就是说此次 GC 有 329KB 的对象存活了下来，从 Eden 区转移到 Survivor From 区。</p>
<img src="YoungGC示例分析2.png" width="450px">

<p><font color="red">3678K-&gt;329K(9728K), 0.0005871 secs</font>：指的是整个 JVM 堆内存的情况，9728K 表示当前堆内存总的可用空间大小，即新生代的 4.5MB + 老年代的 5MB，3678K 表示 GC 前整个 JVM 堆内存已占用空间大小，329KB 表示 GC 后整个 JVM 堆内存已占用空间大小。</p>
<p><font color="red">Times: user=0.00 sys=0.00, real=0.00 secs</font>：表示本次 GC 消耗的时间，单位为秒。</p>
<p>接着我们看下面的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> par new generation   total 4608K, used 2418K [0x00000007bf600000, 0x00000007bfb00000, 0x00000007bfb00000)</span><br><span class="line">  eden space 4096K,  51% used [0x00000007bf600000, 0x00000007bf80a558, 0x00000007bfa00000)</span><br><span class="line">  from space 512K,  64% used [0x00000007bfa80000, 0x00000007bfad2640, 0x00000007bfb00000)</span><br><span class="line">  to   space 512K,   0% used [0x00000007bfa00000, 0x00000007bfa00000, 0x00000007bfa80000)</span><br><span class="line"> concurrent mark-sweep generation total 5120K, used 0K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><font color="red">par new generation   total 4608K, used 2418K</font>：表示使用 ParNew 垃圾收集器负责的新生代总共有 4608KB 可用内存，目前已使用 2418KB。</p>
<p>那么为什么在 JVM 退出之前新生代使用了 2418KB 的内存呢？</p>
<p>因为我们后面又分配了一个 2MB 的数组：byte[] array2 = new byte[2 * 1024 * 1024]; ，所以此时在 Eden 区中一定会有一个 2MB 的数组，也就是 2048K，然后上次 GC 之后存活下来 442K 的对象。但此时疑惑 2048KB + 329KB = 2277KB，那么为什么说新生代使用了 2418KB 呢？按照之前的说法，JVM 还有其他一些附带对象的创建。</p>
<img src="YoungGC示例分析3.png" width="450px">

<p><font color="red">concurrent mark-sweep generation total 5120K, used 0K</font>：CMS 管理的老年代可用空间大小为 5MB，暂未使用。</p>
<p><font color="red">Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</font>：Metaspace 元数据空间的使用情况。</p>
<p>参考 stackoverflow 的资料：<a href="https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout" target="_blank" rel="noopener">Understanding metaspace line in JVM heap printout</a>，翻译如下：</p>
<p>在 JDK1.8 版本中取消了 PermGen。取而代之的是 MetaSpace，方法区在 JDK1.8 以后移至 MetaSpace。JDK1.8 开始把类的元数据放到本地内存，称之为 MetaSpace。理论上本地内存剩余多少，MetaSpace 就有多大，当然我们也不可能无限制的增大 MetaSpace，需要用 -XX:MaxMetaSpaceSize 来指定 MetaSpace 区域大小。</p>
<img src="Metaspace元数据空间使用情况.png" width="400px">

<p>MetaSpace 由一个或多个虚拟空间组成。虚拟空间是操作系统的连续存储空间，虚拟空间是按需分配的。当被分配时，虚拟空间会向操作系统预留（reserved）空间，但还没有被提交（committed）。MetaSpace 的预留空间是全部虚拟空间的大小。虚拟空间的最小分配单元是 MetaChunk（简称 Chunk）。当新的 Chunk 被分配至虚拟空间时，与 Chunk 相关的内存空间被提交了。MetaSpace 的 committed 指的是所有 Chunk 占有的空间。每个 Chunk 占据空间不同，当一个类加载器被 GC 时，所有与之关联的 Chunk 被释放。这些被释放的 Chunk 被维护在一个全局的释放数组里。MetaSpace 的 capacity 指的是所有未被释放的 Chunk 占据的空间。</p>
<p>这么看 GC 日志发现自己 committed 是 4864K，capacity 4486K。有一部分的 MetaChunk 已经被释放了，代表有类加载器被回收了。</p>
<p><font color="red">class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</font>：Class 空间的使用情况。</p>
<p>关于 Metaspace 与 Class 空间的关系可以参考资料：<a href="https://juejin.im/post/5ca033f5f265da30807fe126" target="_blank" rel="noopener">聊聊 JVM 的 CompressedClassSpace</a>。</p>
<h2 id="1-2-Young-GC-后触发对象进入老年代"><a href="#1-2-Young-GC-后触发对象进入老年代" class="headerlink" title="1.2 Young GC 后触发对象进入老年代"></a>1.2 Young GC 后触发对象进入老年代</h2><p>关于 Young GC 后触发对象进入老年代的时机可以参考“<a href>JVM-02-垃圾收集器与内存分配策略</a>”中内存分配策略的流程图。</p>
<p>对象进入老年代的 4 个常见的时机：</p>
<ol>
<li>动态年龄判断后进入老年代； </li>
<li>长期存活对象进入老年代；</li>
<li>一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代；</li>
<li>大对象直接进入老年代；</li>
</ol>
<p>以下实战演示上述 4 种常见的进入老年代的时机情形。</p>
<h3 id="1-2-1-动态年龄判断后进入老年代"><a href="#1-2-1-动态年龄判断后进入老年代" class="headerlink" title="1.2.1 动态年龄判断后进入老年代"></a>1.2.1 动态年龄判断后进入老年代</h3><p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">300</span> * <span class="number">1024</span>];  <span class="comment">// 可以修改此处的大小，多次执行观察日志输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第一次触发 Young GC</span></span><br><span class="line">        array3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第二次触发 Young GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 次，默认 15 次</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.3.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.3.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.075: [GC (Allocation Failure) 0.075: [ParNew: 8139K-&gt;621K(9216K), 0.0005523 secs] 8139K-&gt;621K(19456K), 0.0006159 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.076: [GC (Allocation Failure) 0.076: [ParNew: 7789K-&gt;0K(9216K), 0.0020209 secs] 7789K-&gt;604K(19456K), 0.0020521 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 604K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代3.png" width="950px">

<p>初始分配给 array1 和 array2 的内存空间，其中包括一些辅助的未知对象，当需要给 array3 分配 7MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<img src="模拟长期存活对象直接进入老年代4.png" width="950px">

<p>Young GC 之后在 Survivor 区中有 621KB 的存活对象，其中包括 300KB 的 array2 数组对象，和其他 321KB 的未知对象，当需要给 array4 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第二次 Young GC。</p>
<p>因为第一次 Young GC 之后存在于 Survivor 区中的存活对象占用空间已经超过 Survivor 区的 50%，并且这些存活对象在此之前已经躲过了第一次 GC，所以在第二次 Young GC 的时候，如果在 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<p>当调整 array3 为 128KB 时，观察日志结果又有什么不同呢？</p>
<p>查看 gc.3.log 日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.075: [GC (Allocation Failure) 0.075: [ParNew: 7967K-&gt;450K(9216K), 0.0004673 secs] 7967K-&gt;450K(19456K), 0.0005300 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.076: [GC (Allocation Failure) 0.076: [ParNew: 7618K-&gt;528K(9216K), 0.0003850 secs] 7618K-&gt;528K(19456K), 0.0004124 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2822K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  28% used [0x00000007bec00000, 0x00000007bee3d8a0, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  51% used [0x00000007bf400000, 0x00000007bf484250, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到由于没有达到动态年龄判断指定的的规则，所以只是一次平常的 Young GC，并没有存活对象进入老年代。</p>
<h3 id="1-2-2-长期存活对象进入老年代"><a href="#1-2-2-长期存活对象进入老年代" class="headerlink" title="1.2.2 长期存活对象进入老年代"></a>1.2.2 长期存活对象进入老年代</h3><p>接着上述的演示，我们可以稍加调整就可以演示长期存活对象进入老年代的情况。</p>
<p>上述最后当 array3 的大小调整至 128KB 时，发现并不会触发存活对象进入老年代，但是我们可以通过修改 -XX:MaxTenuringThreshold 参数的值为 1，来促进存活对象进入老年代。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];  <span class="comment">// 接着上述的示例代码</span></span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第一次触发 Young GC</span></span><br><span class="line">        array3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第二次触发 Young GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">1</span>          <span class="comment">// 设置长期存活对象年龄 1 岁，默认 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.4.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.4.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.067: [GC (Allocation Failure) 0.067: [ParNew: 7967K-&gt;462K(9216K), 0.0005621 secs] 7967K-&gt;462K(19456K), 0.0006173 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">0.068: [GC (Allocation Failure) 0.068: [ParNew: 7630K-&gt;0K(9216K), 0.0021220 secs] 7630K-&gt;432K(19456K), 0.0021457 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 432K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代1.png" width="950px">

<p>初始分配给 array1 和 array2 的内存空间，其中包括一些辅助的未知对象，当需要给 array3 分配 7MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<img src="模拟长期存活对象直接进入老年代2.png" width="950px">

<p>Young GC 之后在 Survivor 区中有 462KB 的存活对象，其中包括 128KB 的 array2 数组对象，和其他 334KB 的未知对象，当需要给 array4 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第二次 Young GC。</p>
<p>之前已经分析过，该示例是不满足动态年龄判断规则的，所以当修改长期存活对象的年龄为 1 岁时，第二次 Young GC 时，之前为 1 岁的存活对象直接进入老年代。</p>
<h3 id="1-2-3-一次-Young-GC-之后存活对象太多无法放入-Survivor-区而进入老年代"><a href="#1-2-3-一次-Young-GC-之后存活对象太多无法放入-Survivor-区而进入老年代" class="headerlink" title="1.2.3 一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代"></a>1.2.3 一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代</h3><p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line">        array2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.5.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.5.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.077: [GC (Allocation Failure) 0.077: [ParNew: 6943K-&gt;321K(9216K), 0.0016511 secs] 6943K-&gt;2371K(19456K), 0.0017409 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2451K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  31% used [0x00000007bf500000, 0x00000007bf550640, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 2050K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代5.png" width="950px">

<p>初始分配给 array1 三次 2MB 和 array2 128KB 大小的内存空间 ，其中包括一些辅助的未知对象，当需要给 array3 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<p>先看下日志：ParNew: 6943K-&gt;321K，这里清晰的说明了，本次 GC 过后，新生代中存活对象为 321KB。此时明明 array1 变量还引用了一个 2MB 的数组，为什么是 321KB 的存活对象呢？</p>
<p>要搞清楚这个问题必须弄清楚以下两个问题：</p>
<ol>
<li>存活下来的 2MB 的数组和 300KB 的未知对象能放入 1MB 的 Survivor From 区吗？答案是不能。</li>
<li>那此时，是不是把这些存活对象全部放入老年代呢？并不是。</li>
</ol>
<p>继续通过日志进行分析。</p>
<p><font color="red">eden space 8192K,  26% used</font>：首先 Eden 区内一定放入了一个新的 2MB 的数组，就是刚才最后想要分配的那个数组，由 array3 变量引用。</p>
<p><font color="red">from space 1024K,  31% used</font>：发现此时 Survivor From 区中有 300KB 多的对象，其实就是那 300KB 多的未知对象！所以在这里并不是让 2MB 的数组和 300KB 多的未知对象都进入老年代，而是把 300KB 的未知对象放入 Survivor From 区中。</p>
<p><font color="red">concurrent mark-sweep generation total 10240K, used 2050K</font>：此时老年代里确有 2MB 的数组，因此可以认为，Young GC 过后，发现存活下来的对象有 2MB 的数组和 300KB 多的未知对象。此时把 300KB 的未知对象放入 Survivor From 区中，然后 2MB 的数组直接放入老年代。</p>
<h3 id="1-2-4-大对象直接进入老年代"><a href="#1-2-4-大对象直接进入老年代" class="headerlink" title="1.2.4 大对象直接进入老年代"></a>1.2.4 大对象直接进入老年代</h3><p>此场景比较容易模拟。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">5242880</span>  <span class="comment">// 大对象阈值 5MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.6.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.6.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 836K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000007bec00000, 0x00000007becd1028, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>通过日志可以很清晰的明白。</p>
<p><font color="red">eden space 8192K,  10% used</font>：未知对象。</p>
<p><font color="red">concurrent mark-sweep generation total 10240K, used 6144K</font>：大对象直接进入老年代。</p>
<h2 id="1-3-Full-GC"><a href="#1-3-Full-GC" class="headerlink" title="1.3 Full GC"></a>1.3 Full GC</h2><p>对于 Young GC、Old GC、Minor GC、Major GC、Full GC 的理解。</p>
<p>三种常见的触发 Full GC 的、时机：</p>
<ol>
<li>年轻代存活的对象太多并且老年代没有足够空间。</li>
<li>触发 Young GC 之前，老年代可用空间小于了历次 Young GC 后升入老年代的对象的平均大小，就会在 Young GC 之前，提前触发 Full GC。</li>
<li>CMS 收集器当老年代被使用率达到了 92% 的阈值触发 Full GC。</li>
</ol>
<p>下面演示下因为年轻代存活的对象太多并且老年代没有足够空间时，触发 Full GC 的场景。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] array6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">3145728</span>  <span class="comment">// 大对象阈值 3MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.7.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.7.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew (promotion failed): 6943K-&gt;7382K(9216K), 0.0024651 secs]0.074: [CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs] 11039K-&gt;6555K(19456K), [Metaspace: 2655K-&gt;2655K(1056768K)], 0.0044161 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 6555K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>日志分析：</p>
<img src="FullGC示例分析1.png" width="450px">


<p>接下来会分配 array6，那么此时还能放得下 2MB 的对象么？不可能了，因为 Eden 区已经放不下了。因此此时会直接触发一次 Young GC。</p>
<p>ParNew (promotion failed): 6943K-&gt;7382K(9216K)：日志显示原来有 7000KB 左右的对象，Young GC 之后发现一个都回收不掉，因为上述几个数组都被变量引用了。</p>
<p>所以此时，一定会直接把这些对象放入到老年代里去，但是此时老年代里已经有一个 4MB 的数组了，还能放的下 3 个 2MB 的数组和 1 个 128KB 的数组吗？明显是不行的，此时一定会超过老年代的 10MB 大小。所以此时我们看日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs] 11039K-&gt;6555K(19456K), [Metaspace: 2655K-&gt;2655K(1056768K)], 0.0044161 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<p>可以清晰看到，此时执行了 CMS 垃圾回收器的 Full GC，Full GC 其实就是会对老年代进行 Old GC，同时一般会跟一次 Young GC 关联，还会触发一次元数据区（永久代）的 GC。在 CMS 的 Full GC 之前，就已经触发过 Young GC 了，此时可以看到 Young GC 就已经执行过了，接着就是执行针对老年代的 Old GC，日志：<font color="red">CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs</font>。</p>
<p>这里看到老年代从 8MB 左右的对象占用，变成了 6MB 左右的对象占用，这是怎么个过程呢？很简单，一定是在 Young GC 之后，先把 2 个 2MB 的数组放入了老年代，如下图。</p>
<img src="FullGC示例分析2.png" width="450px">

<p>此时要继续放 1 个 2MB 的数组和 1 个 128KB 的数组到老年代，一定会放不下，所以此时就会触发 CMS 的 Full GC 然后此时就会回收掉那个 4MB 的数组，因为他已经没人引用了，如下图所示。</p>
<img src="FullGC示例分析3.png" width="450px">

<p>接着放入进去 1 个 2MB 的数组和 1 个 128KB 的数组，如下图所示。</p>
<div class="note warning">
            <p>疑问：为什么 1 个 128KB 的数组不会进 Survivor 呢？是因为已经发生过 Young GC 了，所以意思是只有在 Young GC 发生的时候才会进入 Survivor 区吗？待验证。</p>
          </div>

<img src="FullGC示例分析4.png" width="450px">

<p>所以再看 CMS 的垃圾回收日志：CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs，从回收前的 8MB 变成了 6MB，就是上图所示。</p>
<p>最后在 CMS 的 Full GC 执行完毕之后，其实年轻代的对象都进入了老年代，此时最后一行代码要在年轻代分配 2MB 的数组就可以成功了，如下图。</p>
<img src="FullGC示例分析5.png" width="450px">


<h1 id="2-虚拟机性能监控与故障处理工具"><a href="#2-虚拟机性能监控与故障处理工具" class="headerlink" title="2 虚拟机性能监控与故障处理工具"></a>2 虚拟机性能监控与故障处理工具</h1><h2 id="2-1-JDK-命令行工具"><a href="#2-1-JDK-命令行工具" class="headerlink" title="2.1 JDK 命令行工具"></a>2.1 JDK 命令行工具</h2><h3 id="2-1-1-jps：虚拟机进程状况工具（JVM-Process-Status-Tool）"><a href="#2-1-1-jps：虚拟机进程状况工具（JVM-Process-Status-Tool）" class="headerlink" title="2.1.1 jps：虚拟机进程状况工具（JVM Process Status Tool）"></a>2.1.1 jps：虚拟机进程状况工具（JVM Process Status Tool）</h3><p>jps 命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p>jps 可以通过 RMI 协议查询开启 RMI 服务的远程虚拟进程状态，hostid 为 RMI 注册表中注册的主机名。</p>
<p>jps 常用选项：</p>
<ul>
<li>-q：只输出 LVMID（LVMID 与操作系统的进程 PID 是一致的），省略主类名称。</li>
<li>-m：输出虚拟机进程启动时传递给主类 main 方法的参数。</li>
<li>-l：输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径。</li>
<li>-v：输出虚拟机进程启动时的 JVM 参数。</li>
</ul>
<h3 id="2-1-2-jstat：虚拟机统计信息监视工具（JVM-Statistics-Monitoring-Tool）"><a href="#2-1-2-jstat：虚拟机统计信息监视工具（JVM-Statistics-Monitoring-Tool）" class="headerlink" title="2.1.2 jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）"></a>2.1.2 jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）</h3><p>jstat 命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>

<p>jstat 选项：</p>
<ul>
<li>-class：类加载统计</li>
<li>-gc：垃圾回收统计</li>
<li>-gccapacity：堆内存统计</li>
<li>-gcutil：汇总垃圾回收统计</li>
<li>-gccause：与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</li>
<li>-gcnew：新生代垃圾回收统计</li>
<li>-gcnewcapacity：新生代内存统计</li>
<li>-gcold：老年代垃圾回收统计</li>
<li>-gcoldcapacity：年代内存统计</li>
<li>-gcmetacapacity：元空间内存统计</li>
<li>-compiler：编译统计</li>
<li>-printcompilation：编译方法统计</li>
</ul>
<p>虽然有如此多的选项支持，但是最常用、最完整、最实用的还是 jstat -gc 命令，接下来看下该命令的执行结果与展示的信息：</p>
<img src="jstat命令gc日志.png" width="850px">


<p>对于此命令下，我们需要关注的几个点：</p>
<ol>
<li>新生代对象增长的速率</li>
<li>Young GC 的触发频率和每次耗时</li>
<li>每次 Young GC 后有多少对象是存活和进入老年代</li>
<li>Full GC 的触发时机和耗时</li>
</ol>
<p>其中新生代对象增长的速率与 Young GC 的触发频率和每次耗时可以通过命令清晰的获取到相关信息。<font color="red">那怎么评估每次 Young GC 后有多少对象是存活和进入老年代呢？</font></p>
<p>其实每次 Young GC 过后有多少对象会存活下来，这个没法直接看出来，但是有办法可以大致推测出来。我们可以很容易推算出来高峰期的时候多久发生一次 Young GC，比如 3 分钟会有一次 Young GC，那么此时我们可以执行下述 jstat 命令：jstat -gc PID 180000 10。这就相当于是让他每隔三分钟执行一次统计，连续执行 10 次。此时大家可以观察一下，每隔三分钟之后发生了一次 Young GC，此时 Eden、Survivor、老年代的对象变化。正常来说，Eden 区肯定会在几乎放满之后重新变得里面对象很少，比如 800MB 的空间就使用了几十 MB。Survivor 区肯定会放入一些存活对象，老年代可能会增长一些对象占用。所以这里的关键，就是观察老年代的对象增长速率。从一个正常的角度来看，老年代的对象是不太可能不停的快速增长的，因为普通的系统其实没那么多长期存活的对象。如果你发现比如每次 Young GC 过后，老年代对象都要增长几十 MB，那很有可能就是你一次 Young GC 过后存活对象太多了。存活对象太多，可能导致放入 Survivor 区域之后触发了动态年龄判定规则进入老年代，也可能是 Survivor 区域放不下了，所以大部分存活对象进入老年代。最常见的就是这种情况。如果你的老年代每次在 Young GC 过后就新增几百 KB，或者几 MB 的对象，这个还算情有可缘，但是如果老年代对象快速增长，那一定是不正常的。所以通过上述观察策略，你就可以知道每次 Young GC 过后多少对象是存活的，实际上 Survivor 区域里的和进入老年代的对象，都是存活的。你也可以知道老年代对象的增长速率，比如每隔 3 分钟一次 Young GC，每次会有 50MB 对象进入老年代，这就是年代对象的增长速率，每隔 3 分钟增长 50MB。</p>
<p><font color="red">关于 Full GC 的触发时机和耗时？</font></p>
<p>只要知道了老年代对象的增长速率，那么 Full GC 的触发时机就很清晰了，比如老年代总共有 800MB 的内存，每隔3分钟新增 50MB 对象，那么大概每小时就会触发一次 Full GC。然后可以看到 jstat 打印出来的系统运行起劲为止的 Full GC 次数以及总耗时，比如一共执行了 10 次 Full GC，共耗时30s，每次 Full GC 大概就是需要耗费 3s 左右。</p>
<h3 id="2-1-3-jmap：Java-内存映像工具（Memory-Map-for-Java）"><a href="#2-1-3-jmap：Java-内存映像工具（Memory-Map-for-Java）" class="headerlink" title="2.1.3 jmap：Java 内存映像工具（Memory Map for Java）"></a>2.1.3 jmap：Java 内存映像工具（Memory Map for Java）</h3><p>其实如果单单只是要了解 JVM 的运行状况，然后去进行 JVM GC 优化，通常来说 jstat 就完全够用了，但是有的时候可能我们会发现 JVM 新增对象的速度很快，然后就想要去看看，到底什么对象占据了那么多的内存。如果发现有的对象在代码中可以优化一下创建的时机，避免那种对象对内存占用过大，那么也许甚至可以去反过来优化一下代码。当然，其实如果不是出现 OOM 那种极端情况，也并没有那么大的必要去着急优化代码。但是这篇文章我们来学习一下如何了解线上系统 JVM 中的对象分布，也是有好处的，比如上述的案例中就发现年轻代里总是有一些未知对象，大家是不是会很好奇？如果可以看到 JVM中这些对象到底是什么就好了，所以学习一下这个技巧是有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary                                 # 显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;      # 打印 Java 对象堆的柱状图，如果指定了“live”子选项，则仅计算活动对象</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics                           # 打印类加载统计信息</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization      # 显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format                   # 生成 Java 堆转储快照</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,   # 是否 dump 出存活的对象</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo       # 当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-jhat：虚拟机堆转储快照分析工具（JVM-Heap-Analysis-Tool）"><a href="#2-1-4-jhat：虚拟机堆转储快照分析工具（JVM-Heap-Analysis-Tool）" class="headerlink" title="2.1.4 jhat：虚拟机堆转储快照分析工具（JVM Heap Analysis Tool）"></a>2.1.4 jhat：虚拟机堆转储快照分析工具（JVM Heap Analysis Tool）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being &quot;new&quot;.</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br><span class="line">All boolean options default to &quot;true&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># jhat dump.bin </span><br><span class="line">Reading from dump.bin...</span><br><span class="line">Dump file created Sun Nov 24 10:42:54 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 1321689 objects...</span><br><span class="line">Chasing references, expect 264 dots........................................................................................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references........................................................................................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<img src="jhat图1.png" width="850px">


<h3 id="2-1-5-jstack：Java-堆栈跟踪工具（Strack-Trace-for-Java）"><a href="#2-1-5-jstack：Java-堆栈跟踪工具（Strack-Trace-for-Java）" class="headerlink" title="2.1.5 jstack：Java 堆栈跟踪工具（Strack Trace for Java）"></a>2.1.5 jstack：Java 堆栈跟踪工具（Strack Trace for Java）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) # 当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">    -m  to print both java and native frames (mixed mode)                                # 除堆栈</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure>




<h2 id="2-2-JDK-可视化工具"><a href="#2-2-JDK-可视化工具" class="headerlink" title="2.2 JDK 可视化工具"></a>2.2 JDK 可视化工具</h2><h3 id="2-2-1-jconsole：Java-监视与管理控制台"><a href="#2-2-1-jconsole：Java-监视与管理控制台" class="headerlink" title="2.2.1 jconsole：Java 监视与管理控制台"></a>2.2.1 jconsole：Java 监视与管理控制台</h3><h3 id="2-2-2-visualvm：多合一故障处理工具"><a href="#2-2-2-visualvm：多合一故障处理工具" class="headerlink" title="2.2.2 visualvm：多合一故障处理工具"></a>2.2.2 visualvm：多合一故障处理工具</h3>
    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/26/JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="next" title="JVM-04-虚拟机类加载机制">
                  <i class="fa fa-chevron-left"></i> JVM-04-虚拟机类加载机制
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/26/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-ThreadPoolExecutor/" rel="prev" title="并发基础-ThreadPoolExecutor">
                  并发基础-ThreadPoolExecutor <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-垃圾收集实战"><span class="nav-text">1 垃圾收集实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Young-GC"><span class="nav-text">1.1 Young GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Young-GC-后触发对象进入老年代"><span class="nav-text">1.2 Young GC 后触发对象进入老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-动态年龄判断后进入老年代"><span class="nav-text">1.2.1 动态年龄判断后进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-长期存活对象进入老年代"><span class="nav-text">1.2.2 长期存活对象进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-一次-Young-GC-之后存活对象太多无法放入-Survivor-区而进入老年代"><span class="nav-text">1.2.3 一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-大对象直接进入老年代"><span class="nav-text">1.2.4 大对象直接进入老年代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Full-GC"><span class="nav-text">1.3 Full GC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-虚拟机性能监控与故障处理工具"><span class="nav-text">2 虚拟机性能监控与故障处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-JDK-命令行工具"><span class="nav-text">2.1 JDK 命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-jps：虚拟机进程状况工具（JVM-Process-Status-Tool）"><span class="nav-text">2.1.1 jps：虚拟机进程状况工具（JVM Process Status Tool）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-jstat：虚拟机统计信息监视工具（JVM-Statistics-Monitoring-Tool）"><span class="nav-text">2.1.2 jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-jmap：Java-内存映像工具（Memory-Map-for-Java）"><span class="nav-text">2.1.3 jmap：Java 内存映像工具（Memory Map for Java）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-jhat：虚拟机堆转储快照分析工具（JVM-Heap-Analysis-Tool）"><span class="nav-text">2.1.4 jhat：虚拟机堆转储快照分析工具（JVM Heap Analysis Tool）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-jstack：Java-堆栈跟踪工具（Strack-Trace-for-Java）"><span class="nav-text">2.1.5 jstack：Java 堆栈跟踪工具（Strack Trace for Java）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-JDK-可视化工具"><span class="nav-text">2.2 JDK 可视化工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-jconsole：Java-监视与管理控制台"><span class="nav-text">2.2.1 jconsole：Java 监视与管理控制台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-visualvm：多合一故障处理工具"><span class="nav-text">2.2.2 visualvm：多合一故障处理工具</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="王鹏博"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">王鹏博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王鹏博</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
