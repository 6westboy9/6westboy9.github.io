<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","width":300,"display":"post","offset":13,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="1 类的加载过程1.1 类的生命周期这些阶段通常都是相互交叉地混合式进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。在如下几种情况下，Java 虚拟机将结束生命周期： 执行了 System.exit() 方法（实质为给虚拟机本身发送一个执行使其终止）。 程序正常执行结束。 程序在执行过程中遇到了异常或错误而异常终止。 由于操作系统出现错误而导致 Java 虚拟机进程终止。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-04-虚拟机类加载机制">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;index.html">
<meta property="og:site_name" content="Westboy&#39;Blog">
<meta property="og:description" content="1 类的加载过程1.1 类的生命周期这些阶段通常都是相互交叉地混合式进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。在如下几种情况下，Java 虚拟机将结束生命周期： 执行了 System.exit() 方法（实质为给虚拟机本身发送一个执行使其终止）。 程序正常执行结束。 程序在执行过程中遇到了异常或错误而异常终止。 由于操作系统出现错误而导致 Java 虚拟机进程终止。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;类的生命周期.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;JVM自带类加载器加载路径.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;双亲委派模型.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;JDBC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;ServiceLoader%E5%8A%A0%E8%BD%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;MySQL%E7%9A%84Driver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8MyTest16.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD%E7%9B%91%E6%8E%A7%E7%A4%BA%E4%BE%8B.png">
<meta property="og:updated_time" content="2019-11-26T08:58:03.028Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;26&#x2F;JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6&#x2F;类的生命周期.png">

<link rel="canonical" href="http://yoursite.com/2019/11/26/JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JVM-04-虚拟机类加载机制 | Westboy'Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Westboy'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM-04-虚拟机类加载机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 16:58:03" itemprop="dateCreated datePublished" datetime="2019-11-26T16:58:03+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1 类的加载过程"></a>1 类的加载过程</h1><h2 id="1-1-类的生命周期"><a href="#1-1-类的生命周期" class="headerlink" title="1.1 类的生命周期"></a>1.1 类的生命周期</h2><img src="./类的生命周期.png" width="800px"><p>这些阶段通常都是相互交叉地混合式进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p><p>在如下几种情况下，Java 虚拟机将结束生命周期：</p><ul>
<li>执行了 System.exit() 方法（实质为给虚拟机本身发送一个执行使其终止）。</li>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于<font color="red">操作系统出现错误</font>而导致 Java 虚拟机进程终止。</li>
</ul><a id="more"></a><!-- ![](类的生命周期.png) -->






<h2 id="1-2-主动引用"><a href="#1-2-主动引用" class="headerlink" title="1.2 主动引用"></a>1.2 主动引用</h2><p>虚拟机规范严格规定有且只有 5 种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始），称为主动引用：</p>
<ol>
<li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，生成这 4 条指令的最常见场景：① 使用 new 实例化对象；② 读取或设置一个类的 static 字段（被 final 修饰，已在编译器把结果放入常量池的静态字段除外）；③ 调用类的静态方法。</li>
<li>使用 java.lang.reflect 包的方法对类进行<font color="red">反射</font>调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类时，如果其父类还没初始化，需先初始化父类。<font color="red">这点类与接口具有不同的表现</font>，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。<font color="red">注意：接口的实现类在初始化时也一样不会要求接口完成初始化</font>。</li>
<li>当虚拟机启动时，用户需要指定一个执行的主类，即包含 main 方法的那个类，虚拟机会先初始化这个主类。</li>
<li>JDK 1.7 动态语言支持：如果一个 java.lang.invoke.MethodHandle 的实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<h2 id="1-3-被动引用"><a href="#1-3-被动引用" class="headerlink" title="1.3 被动引用"></a>1.3 被动引用</h2><p>除此之外都不会触发初始化，称为被动引用，主要列举以下 3 种情况：</p>
<ol>
<li>通过子类引用父类静态字段，只会导致父类的初始化而不会导致子类初始化。HotSpot 可通过 -XX:+TraceClassLoading 参数导致子类的加载。</li>
<li>Array[] arr = new Array[10]; 不会触发 Array 类初始化。</li>
<li>static final VAR 在编译阶段会存入调用类的常量池，通过 ClassName.VAR 引用不会触发 ClassName 初始化。注意：<font color="red">当一个常量的值并非编译期间可以确定，那么其值就不会放入调用类的常量池中，因此当使用该常量值，就会导致该常量所在类的初始化</font>。</li>
<li><font color="red">调用 ClassLoader 的 loadClass 方法不会导致类的初始化</font>。</li>
</ol>
<h2 id="1-4-类的加载"><a href="#1-4-类的加载" class="headerlink" title="1.4 类的加载"></a>1.4 类的加载</h2><p>类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个 java.lang.Class 对象用来封装类在方法区内的数据结构。<font color="red">JVM 规范中并未说明 Class 对象位于哪里，Hotspot 虚拟机将其放在方法区中</font>。</p>
<p>JVM 规范允许类加载器在预料某个类将要被使用时就<font color="red">预先加载</font>它，如果在预先加载的过程中遇到了 .class 文件缺失或存在错误，类加载器会在程序首次主动引用该类时报告 <font color="red">LinkageError</font> 错误。如果这个类一直没有被程序主动引用，那么<font color="red">类加载器就不会报告错误</font>。</p>
<blockquote>
<p>通过添加：-XX:+TraceClassLoading 程序运行时将打印类的加载过程。</p>
</blockquote>
<p>类加载的 .class 文件的来源：</p>
<ol>
<li>从 ZIP 包中读取；</li>
<li>从网络中获取；</li>
<li>运行时计算生成，比如动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 类来为特定接口生成形式为 $Proxy 的代理类的二进制字节流；</li>
<li>有其他文件生成，比如 JSP；</li>
<li>从数据库中读取。</li>
</ol>
<h2 id="1-5-连接-验证"><a href="#1-5-连接-验证" class="headerlink" title="1.5 连接-验证"></a>1.5 连接-验证</h2><p>目的： 确保 class 文件中的字节流信息符合虚拟机的要求。</p>
<p>4 个验证过程：</p>
<ol>
<li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” 0xCAFEBABE；</li>
<li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）；</li>
<li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）；</li>
<li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验。</li>
</ol>
<blockquote>
<p>这个操作虽然重要，但不是必要的，可以通过 -Xverify:none 关掉。</p>
</blockquote>
<h2 id="1-6-连接-准备"><a href="#1-6-连接-准备" class="headerlink" title="1.6 连接-准备"></a>1.6 连接-准备</h2><p>描述： 为静态变量在方法区分配内存，并设置默认的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备后为 0，value 的赋值指令 putstatic 会被放在 &lt;client&gt;() 方法中，&lt;client&gt;() 方法</span></span><br><span class="line"><span class="comment">// 会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 准备后为 123，因为被 static final 赋值之后 value 就不能再修改了，所以在这里进行了赋值</span></span><br><span class="line"><span class="comment">// 之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


<h2 id="1-7-连接-解析"><a href="#1-7-连接-解析" class="headerlink" title="1.7 连接-解析"></a>1.7 连接-解析</h2><p>描述： 将常量池中的符号引用替换为直接引用。在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</p>
<p>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</p>
<p>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</p>
<h2 id="1-8-初始化"><a href="#1-8-初始化" class="headerlink" title="1.8 初始化"></a>1.8 初始化</h2><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，<font color="red">初始化阶段是执行类构造器 &lt;client&gt;() 方法的过程</font>。</p>
<ol>
<li>&lt;client&gt;() 方法是由编译器自动收集类中的所有<font color="red">类变量的赋值动作</font>和<font color="red">静态语句块</font>（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
<li>&lt;client&gt;() 方法与类的构造函数（或者说实例构造器 <font color="blue">init&lt;&gt;()</font> 方法）不同，它<font color="red">不需要显示地调用父类构造器，虚拟机会保证在子类的 &lt;client&gt;() 方法执行之前，父类的 &lt;client&gt;() 方法已经执行完毕</font>。因此在虚拟机中第一个被执行的 &lt;client&gt;() 方法的类肯定是 java.lang.Object。</li>
<li>由于父类的 &lt;client&gt;() 方法先执行，也就意味着<font color="red">父类中定义的类变量的赋值和静态语句块要先于子类</font>。</li>
<li>&lt;client&gt;() 方法对于类或者接口<font color="red">并不是必须的</font>。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 &lt;client&gt;() 方法。<font color="red">但接口与类不同的是</font>，执行接口的 &lt;client&gt;() 方法不需要先执行父接口的 &lt;client&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，<font color="red">接口的实现类在初始化时也一样不会执行接口的 &lt;client&gt;() 方法</font>。</li>
<li>虚拟机会保证一个类的 &lt;client&gt;() 方法在多线程执行环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;client&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;client&gt;() 方法完毕。如果在一个类的 &lt;client&gt;() 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。需要注意的是，其他线程虽然会被阻塞，但如果执行 &lt;client&gt;() 方法的那条线程退出 &lt;client&gt;() 方法后，其他线程唤醒之后不会再次进入 &lt;client&gt;() 方法。<font color="red">同一个类加载器下，一个类型只会初始化一次</font>。 </li>
</ol>
<h2 id="1-9-实战"><a href="#1-9-实战" class="headerlink" title="1.9 实战"></a>1.9 实战</h2><h3 id="1-9-1-子类与父类中静态字段的加载与初始化"><a href="#1-9-1-子类与父类中静态字段的加载与初始化" class="headerlink" title="1.9.1 子类与父类中静态字段的加载与初始化"></a>1.9.1 子类与父类中静态字段的加载与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p>当在 Child 类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"welcome"</span>; <span class="comment">// 添加代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// Child static block</span></span><br><span class="line"><span class="comment">// welcome</span></span><br></pre></td></tr></table></figure>

<p>结论 1：初始化一个类时，其父类还没初始化，需先初始化父类。<br>结论 2：通过子类引用父类静态字段，只会导致父类的初始化而不会导致子类初始化。</p>
<p>通过添加：-XX:+TraceClassLoading 观察上述两种情况下类的加载过程。</p>
<div class="note success">
            <p>-XX:+option，表示开启 option 选项，默认没有开启需要开启的情况。<br>-XX:-option，表示关闭 option 选项，默认已经开启需要关闭的情况。<br>-XX:option=value，表示将 option 选项的值设置为 value。</p>
          </div>


<p>根据 《深入理解Java虚拟机：JVM高级特性与最佳实践》 得知，其<font color="red">子类的加载是因为使用 -XX:+TraceClassLoading 参数</font>。</p>
<h3 id="1-9-2-编译期常量所在类的初始化"><a href="#1-9-2-编译期常量所在类的初始化" class="headerlink" title="1.9.2 编译期常量所在类的初始化"></a>1.9.2 编译期常量所在类的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：hello world，因为 static final 类型的变量在编译期已经存入 MyTest 类的常量池中。所以，通过 Parent.str 引用不会触发 Parent 初始化。将上述代码反编译结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MyTest.class</span></span><br><span class="line">Compiled from "MyTest.java"</span><br><span class="line">public class com.westboy.MyTest &#123;</span><br><span class="line">  public com.westboy.MyTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #4                  // String hello world</span><br><span class="line">       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中扩展几个常用的助记符：</p>
<div class="note success">
            <p>ldc：表示将 int，float 或是 String 类型的常量值从常量池中推送至栈顶。<br>bipush：表示将单字节（-128 ~ 127）的常量值推送至栈顶。<br>sipush：表示将一个短整型常量值（-32768 ~ 32767）常量值推送至栈顶。<br>iconst_1：表示将 int 类型 1 推送至栈顶（iconst_m1，iconst_0 ~ iconst_5，HotSpot JVM 可能认为 int 类型 -1 ~ 5 是比较常用的类型，所以单另使用一种助记符）。</p>
          </div>

<p>关于上述的 iconst 的范围可参考：com.sun.org.apache.bcel.internal.generic.ICONST 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ICONST</span> <span class="keyword">extends</span> <span class="title">Instruction</span> <span class="keyword">implements</span> <span class="title">ConstantPushInstruction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ICONST</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">short</span>)<span class="number">3</span>, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= -<span class="number">1</span> &amp;&amp; i &lt;= <span class="number">5</span>) &#123; <span class="comment">// 就是上述的范围（iconst_m1，iconst_0 ~ iconst_5）</span></span><br><span class="line">            <span class="keyword">super</span>.setOpcode((<span class="keyword">short</span>)(<span class="number">3</span> + i));</span><br><span class="line">            <span class="keyword">this</span>.value = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassGenException(<span class="string">"ICONST can be used only for value between -1 and 5: "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也会发现对于助记符 sipush 也有对应的类实现（com.sun.org.apache.bcel.internal.generic.SIPUSH），所以对于这些助记符底层都是通过相应的类进行实现的。</p>
<h3 id="1-9-3-非编译期常量所在类的初始化"><a href="#1-9-3-非编译期常量所在类的初始化" class="headerlink" title="1.9.3 非编译期常量所在类的初始化"></a>1.9.3 非编译期常量所在类的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// 4475c0db-fa99-4c86-9d81-506bde28ec73</span></span><br></pre></td></tr></table></figure>

<p>结论：<font color="red">当一个常量的值并非编译期间可以确定，那么其值就不会放入调用类的常量池中</font>，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类初始化。</p>
<h3 id="1-9-4-数组实例的类型创建时机"><a href="#1-9-4-数组实例的类型创建时机" class="headerlink" title="1.9.4 数组实例的类型创建时机"></a>1.9.4 数组实例的类型创建时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent[] parents1 = <span class="keyword">new</span> Parent[<span class="number">1</span>];</span><br><span class="line">        System.out.println(parents1.getClass());</span><br><span class="line">        System.out.println(parents1.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        Parent[][] parents2 = <span class="keyword">new</span> Parent[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        System.out.println(parents2.getClass());</span><br><span class="line">        System.out.println(parents2.getClass().getSuperclass());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：并没有对 Parent 类进行初始化操作</span></span><br><span class="line"><span class="comment">// class [Lcom.westboy.Parent;</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [[Lcom.westboy.Parent;</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [I</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [C</span></span><br></pre></td></tr></table></figure>

<p>结论：对于数组实例来说，其类型是由 JVM 在运行期动态生成的，表示为：[Lcom.westboy.Parent 这种形式。动态生成的类型，其父类型就是 Object。对于数组来说，JavaDoc 经常将构建成数组的元素称之为 Component，实际上就是将数组降低一个维度后的类型。</p>
<p>反编译执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MyTest.class</span></span><br><span class="line">Compiled from "MyTest.java"</span><br><span class="line">public class com.westboy.MyTest &#123;</span><br><span class="line">  public com.westboy.MyTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: anewarray     #2                  // class com/westboy/Parent</span><br><span class="line">       4: astore_1</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      12: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      15: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      22: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      25: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      28: iconst_1</span><br><span class="line">      29: iconst_1</span><br><span class="line">      30: multianewarray #7,  2             // class "[[Lcom/westboy/Parent;"</span><br><span class="line">      34: astore_2</span><br><span class="line">      35: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      38: aload_2</span><br><span class="line">      39: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      42: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      45: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      48: aload_2</span><br><span class="line">      49: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      52: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      55: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      58: iconst_1</span><br><span class="line">      59: newarray       int</span><br><span class="line">      61: astore_3</span><br><span class="line">      62: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      65: aload_3</span><br><span class="line">      66: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      69: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      72: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      75: aload_3</span><br><span class="line">      76: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      79: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      82: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      85: iconst_1</span><br><span class="line">      86: newarray       char</span><br><span class="line">      88: astore        4</span><br><span class="line">      90: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      93: aload         4</span><br><span class="line">      95: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      98: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">     101: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展助记符：</p>
<div class="note success">
            <p>anewarray：表示创建一个一维引用类型（如类，接口和数组）的数组，并将其引用值压入栈顶。<br>newarray：表示创建一个指定的原始类型（如 int，float，char 等）的数组，并将其引用值压入栈顶。<br>multianewarray：表示创建一个多维引用类型（如类，接口和数组）的数组，并将其引用值压入栈顶。</p>
          </div>

<p>ClassLoader API Doc 中的片段：<font color="red">数组类型的 Class 对象并不是由类加载器创建的，它是在 Java 运行期自动创建的，通过数组获取的类加载器是与其数组中元素类型通过 Class.getClassLoader 方法获取的类加载器是一致的，如果元素类型是原生类型，那么数组类是没有类加载器的</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">System.out.println(String.class.getClassLoader());</span><br><span class="line">System.out.println(strings.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// null # String 类型由启动类加载器加载，所有返回为 null</span></span><br><span class="line"><span class="comment">// null # 通过数组获取的类加载器是与其数组中元素类型通过 Class.getClassLoader 方法获取的类加载器是一致的</span></span><br><span class="line"></span><br><span class="line">MyTest15[] myTest15s = <span class="keyword">new</span> MyTest15[<span class="number">2</span>];</span><br><span class="line">System.out.println(MyTest15.class.getClassLoader());</span><br><span class="line">System.out.println(myTest15s.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2 # MyTest15 由应用类加载器加载</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(<span class="keyword">int</span>.class.getClassLoader());</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// null # 注意此处的 null 与 上述的 null 不一样，数组类是没有类加载器的</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="1-9-5-接口相关的初始化"><a href="#1-9-5-接口相关的初始化" class="headerlink" title="1.9.5 接口相关的初始化"></a>1.9.5 接口相关的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild</span> <span class="keyword">implements</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>结论 1：接口的实现类在初始化时不会要求接口的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyChild</span> <span class="keyword">extends</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// MyChild invoked</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure>

<p>结论 2：接口初始化时，不要求其父接口完成初始化。</p>
<h3 id="1-9-6-初始化阶段分析"><a href="#1-9-6-初始化阶段分析" class="headerlink" title="1.9.6 初始化阶段分析"></a>1.9.6 初始化阶段分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"counter1: "</span> + Singleton.counter1);</span><br><span class="line">        System.out.println(<span class="string">"counter2: "</span> + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>; <span class="comment">// 标注 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// counter1: 1</span></span><br><span class="line"><span class="comment">// counter2: 1</span></span><br></pre></td></tr></table></figure>

<p>变更下标注 1 行代码的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// counter1: 1</span></span><br><span class="line"><span class="comment">// counter2: 0</span></span><br></pre></td></tr></table></figure>

<p><font color="red">为什么只是变更了一下位置结果却不一样呢？</font></p>
<p>首先按照加载-连接-初始化的流程，在连接的准备阶段按照从上到下的顺序会对 counter1 和 counter2 和 singleton 三个静态变量分配内存，并初始化默认值，即连接阶段的结果为：counter1 = 0，counter2 = 0 和 singleton = null，又因为 main 方法调用 Singleton.getInstance() 时为上述主动引用中的第一种情况中的第 ③ 种情况：使用静态方法，会使得 Singleton 进行初始化，初始化阶段为对静态变量赋予正确的初始值（见下），但是 counter1 与 counter2 没有进行赋值操作取默认值，所以依然没变，接下来对 singleton 进行初始化操作，在使用 Singleton 构造方法生成对象时，又对 counter1 和 counter2 进行了自增运算，并重新赋值，所以在初始化阶段结束之后：counter1 = 1，counter2 = 1。</p>
<p>与第一种情况不同的是 counter2 与 singleton 两个变量交换了位置，按照加载-连接-初始化的流程，连接阶段的结果依然为：counter1 = 0，counter2 = 0 和 singleton = null，但是在初始化阶段，不同于第一种情况，先对 singleton 进行初始化，其初始化完成后 counter1 = 0，counter2 = 0，接下来继续对 counter2 进行初始化，由于没有对 counter2 进行赋值操作取默认值，导致最终结果为：counter1 = 1，counter2 = 0。</p>
<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3 类加载器"></a>3 类加载器</h1><h2 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h2><p><font color="red">Bootsrap ClassLoader：启动类加载器（也称根类加载器）</font>：该类加载器负责加载 JAVA_HOME/jre/lib 或者由 -Xbootclasspath 参数（或者使用 -D 选项指定 sun.boot.class.path ）所指定的路径中的，并且是虚拟机识别的类库到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取启动类加载器所加载的全部 URL 数组</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            System.out.println(urls[i].toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/classes</span></span><br></pre></td></tr></table></figure>



<p><font color="red">Extension ClassLoader：扩展类加载器</font>：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现。它负责加载 JAVA_HOME/jre/lib/ext 或者由 java.ext.dirs 系统指定的目录中的 JAR 包的类。</p>
<p>通过这种方式，就可以为 Java 扩展核心类以外的新功能，只要把自己开发的类打成 JAR 文件，然后放入 JAVA_HOME/jre/lib/ext 路径即可。</p>
<p><font color="red">System ClassLoader：系统类加载器（也称应用类加载器）</font>：这个加载器由 sun.misc.Launcher$AppClassLoader 实现。它负责在 JVM 启动时加载来自 java 命令的 -classpath 选项、java.class.path 系统属性，或 CLASSPATH 环境变量所指定的 JAR 包和类路径。程序可以用通过 ClassLoader 的静态方法 getSystemClassLoader() 方法来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以应用类加载器作为父加载器。</p>
<p><font color="blue">扩展-1</font>：可以通过以下方法获取到每个类加载器默认所加载的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"sun.boot.class.path"</span>, <span class="string">"启动类加载器"</span>);</span><br><span class="line">        print(<span class="string">"java.ext.dirs"</span>, <span class="string">"扩展类加载器"</span>);</span><br><span class="line">        print(<span class="string">"java.class.path"</span>, <span class="string">"应用类加载器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        System.out.println(classLoaderName + <span class="string">"加载路径: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : System.getProperty(s).split(<span class="string">":"</span>)) &#123;</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ➜  classes git:(master) ✗ java com.westboy.MyTest18 使用 java 命令执行，如果在 IDEA 下执行结果不一样</span></span><br><span class="line"><span class="comment">// 启动类加载器加载路径: </span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/classes</span></span><br><span class="line"><span class="comment">// 扩展类加载器加载路径: </span></span><br><span class="line"><span class="comment">// /Users/westboy/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/ext</span></span><br><span class="line"><span class="comment">// /Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /Network/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /System/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /usr/lib/java</span></span><br><span class="line"><span class="comment">// 应用类加载器加载路径: </span></span><br><span class="line"><span class="comment">// .   &lt;-------------- 注意 . 代表当前的路径</span></span><br></pre></td></tr></table></figure>

<!-- ![](JVM自带类加载器加载路径.png) -->

<!-- <img src="./JVM自带类加载器加载路径.png" width="650px"/> -->

<p><font color="blue">扩展-2</font>：扩展类加载器注意要点：扩展类加载器需要将加载的类打成 jar 放置在加载目录下才能加载，而启动类加载器与应用类加载器只需要将 .class 文件放置在加载目录下即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest22</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyTest22 initializer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyTest22.class.getClassLoader());</span><br><span class="line">        System.out.println(MyTest15.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不打包执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ pwd                                         </span><br><span class="line">/Users/westboy/IdeaProjects/personal/java-learning/shengsiyuan-jvm/target/classes # 当前路径</span><br><span class="line">➜  classes git:(master) ✗ java -Djava.ext.dirs=./ com.westboy.MyTest22</span><br><span class="line">MyTest22 initializer</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest22 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest15 由应用类加载器加载</span><br></pre></td></tr></table></figure>

<p>打包执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ jar cvf test.jar com/westboy/MyTest15.class             # 打包操作 </span><br><span class="line">已添加清单</span><br><span class="line">正在添加: com/westboy/MyTest15.class(输入 = 1121) (输出 = 589)(压缩了 47%)</span><br><span class="line">➜  classes git:(master) ✗ java -Djava.ext.dirs=./ com.westboy.MyTest22            # 打包结束后执行</span><br><span class="line">MyTest22 initializer</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest22 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@33909752                                         # MyTest15 由扩展类加载器加载</span><br></pre></td></tr></table></figure>

<p>结论：<font color="red">可见扩展类加载器需要将加载的类打成 jar 放置在加载目录下才能加载，而启动类加载器与应用类加载器只需要将 .class 文件放置在加载目录下即可</font>。</p>
<p><font color="blue">扩展-3</font>：修改默认的应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证 ClassLoader 类的类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader()); </span><br><span class="line">        <span class="comment">// 间接验证扩展类加载器与应用类加载器的类加载器</span></span><br><span class="line">        System.out.println(Launcher.class.getClassLoader()); </span><br><span class="line">        <span class="comment">// 默认的情况下，java.system.class.loader 属性没有被定义，打印结果为 null，所以应用类加载器默认指向 Launcher$AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>)); </span><br><span class="line">        System.out.println(MyTest23.class.getClassLoader());</span><br><span class="line">        System.out.println(MyTest16.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ java -Djava.system.class.loader=com.westboy.MyTest16 com.westboy.MyTest23 # 修改 java.system.class.loader 属性</span><br><span class="line">null                                        # ClassLoader 是由启动类加载器加载</span><br><span class="line">null                                        # 扩展类加载器与应用类加载器也是由启动类加载器所加载的</span><br><span class="line">com.westboy.MyTest16                        # 默认的类加载器已经被修改</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2   # MyTest23 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2   # MyTest16 由应用类加载器加载</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;null&apos;&#125;            # 可见将 java.system.class.loader 属性设置为 MyTest16 类加载器已经生效</span><br></pre></td></tr></table></figure>

<p>注意：在引用之前 MyTest16 的类加载器的时候，必须添加如下构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因参见：<font color="red">待补充…</font></p>
<!-- ![](获取应用类加载器方法注释.png) -->

<!-- 启动类加载器并不是 Java 类，而其他的加载器是 Java 类，启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。
所有类加载器（除启动类加载器）都被实现为 Java 类。不过，总归要有一个组件来加载第一个 Java 类加载器，从而让整个加载过程能够顺利进行下去，<font color="red">加载第一个纯 Java 类加载器就是启动类加载器的职责</font>。
启动类加载还会负责加载 JRE 正常所需要的基本组件，这包括 java.util 与 java.lang 包中的类等等。 -->

<h2 id="3-2-类的加载机制"><a href="#3-2-类的加载机制" class="headerlink" title="3.2 类的加载机制"></a>3.2 类的加载机制</h2><p>JVM 的类加载机制主要有如下三种。</p>
<p><font color="red">① 全盘负责</font>。所谓全盘负责，就是当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另一个类加载器来加载。<br><font color="red">② 双亲委派（父类委托）</font>。所谓父类委托，则是先让父类加载器视图加载该 Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。<br><font color="red">③ 缓存机制</font>。缓存机制将会保存所有加载过的 Class 都会被缓存，当程序中需要用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区中，这就是为什么修改了 Class 后，必须重启 JVM，程序所做的修改才会生效的原因。</p>
<h2 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h2><!-- ![](双亲委派模型.png) -->

<img src="./双亲委派模型.png" width="650px">

<p>上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系<font color="red">一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）</font>。</p>
<div class="note warning">
            <p>类加载器的父子关系不是通过继承来实现的，比如 AppClassLoader 并不是 ExtClassLoader 的子类，而是说 AppClassLoader 的 parent 成员变量指向 ExtClassLoader 对象。</p>
          </div>


<p><font color="red">双亲委派模型的工作过程</font>：</p>
<p>① 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。<br>② 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。<br>③ 只有当父类加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p><font color="red">双亲委派模型的优点</font>：</p>
<p>① <font color="#0066FF">可以确保 Java 核心库的类型安全</font>：例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。而且这些之间还是不兼容的，相互不可见的（正是命名空间在发挥作用，类加载器的命名空间在下文<a href="#3-5-自定义-ClassLoader">自定义 ClassLoader </a>中会顺带讲解）。<br>② <font color="#0066FF">可以确保 Java 核心类库所提供的类不会被自定义的类所替代</font>。<br>③ <font color="#0066FF">不同类加载器可以为相同名称的类创建额外的命名空间</font>。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个又一个相互隔离的 Java 类空间，这类技术在很多框架中都得到了实际应用。</p>
<div class="note warning">
            <p>TODO 类加载器的命名空间</p>
          </div>


<p><font color="red">双亲委派模型的系统实现</font>：</p>
<p>双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却很简单，实现集中在 java.lang.ClassLoader 的 loadClass 方法中，在其方法中，<font color="red">主要判断逻辑</font>：先检查是否已经被加载过，若没有加载则调用父类加载器的 loadClass 方法，若父类加载器为空默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass 方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-3-破坏双亲委派模型（TODO-简化）"><a href="#3-3-破坏双亲委派模型（TODO-简化）" class="headerlink" title="3.3 破坏双亲委派模型（TODO 简化）"></a>3.3 破坏双亲委派模型（TODO 简化）</h2><p>双亲委派模型<font color="red">并不是一个强制性的约束模型</font>。而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外。</p>
<p>双亲委派模型的<font color="red">第一次“被破坏”</font>其实发生在双亲委派模型出现之前—即 JDK1.2 发布之前。由于双亲委派模型是在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则是 JDK1.0 时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 proceted 方法 findClass，在此之前，用户去继承 java.lang.ClassLoader 的唯一目的就是重写 loadClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal，而这个方法的唯一逻辑就是去调用自己的 loadClass。JDK1.2 之后已不再提倡用户再去覆盖 loadClass 方法，应当把自己的类加载逻辑写到 findClass 方法中，在 loadClass 方法的逻辑里，如果父类加载器加载失败，则会调用自己的 findClass 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。</p>
<p>双亲委派模型的<font color="red">第二次“被破坏”</font>是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的 API。但是，如果基础类又要调用用户的代码，那该怎么办呢？</p>
<p>这并非是不可能的事情，一个典型的例子便是 JNDI 服务，它的代码由启动类加载器去加载（在 JDK1.3 时放进 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的 classpath 下的 JNDI 接口提供者（SPI, Service Provider Interface）的代码，但启动类加载器不可能“认识”之些代码，该怎么办？</p>
<p>为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：<font color="red">线程上下文件类加载器</font>（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI，JDBC，JCE，JAXB 和 JBI 等。</p>
<blockquote>
<p>关于线程上下文件类加载器扩展知识参见：<a href="#3-5-线程上下文类加载器分析">3.5 线程上下文类加载器分析</a></p>
</blockquote>
<div class="note danger">
            <p><strong>双亲委派模型破坏举例</strong>（淘宝面试题）</p><p>原生的 JDBC 中 Driver 驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL 的 mysql-connector-java.jar 中的 Driver 类具体实现的。 原生的 JDBC 中的类是放在 rt.jar 包的，是由启动类加载器进行类加载的，在 JDBC 中的 Driver 类中需要动态去加载不同数据库类型的 Driver 类，而 mysql-connector-java.jar 中的 Driver 类是用户自己写的代码，那<font color="red">启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器。因此，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了</font>。代码分析参见：<a href="#3-4-破坏双亲委派模型的-JDBC-实现案例">3.4 破坏双亲委派模型的-JDBC-实现案例</a></p>
          </div>

<p>双亲委派模型的<font color="red">第三次“被破坏”</font>是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。</p>
<p>OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 坏境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>
<ol>
<li>将 java.＊ 开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</li>
<li>否则，类加载器失败。</li>
</ol>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>
<p>虽然使用了“被破坏”这个词形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可以认为是一种创新。</p>
<h2 id="3-4-破坏双亲委派模型的-JDBC-实现案例"><a href="#3-4-破坏双亲委派模型的-JDBC-实现案例" class="headerlink" title="3.4 破坏双亲委派模型的 JDBC 实现案例"></a>3.4 破坏双亲委派模型的 JDBC 实现案例</h2><p>我们结合 Driver 来看一下在 SPI（Service Provider Inteface）中如何实现破坏双亲委派。</p>
<p>先从 DriverManager 开始看，平时我们通过 DriverManager 来获取数据库的 Connection：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/testdb"</span>;</span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure>

<p>在调用 DriverManager 的时候，会先初始化类，调用其中的静态块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加载Driver的实现类</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了节约空间，笔者省略了一部分的代码，重点来看一下 ServiceLoader.load(Driver.class)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程中的上下文类加载器</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，load 方法调用获取了当前线程中的上下文类加载器，那么上下文类加载器放的是什么加载器呢？在 sun.misc.Launcher 中，我们找到了答案，在 Launcher 初始化的时候，会获取 AppClassLoader，然后将其设置为上下文类加载器，而这个 AppClassLoader，就是之前上文提到的应用类加载器，所以<font color="red">线程上下文类加载器默认情况下就是应用类加载器</font>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Launcher &#123;</span><br><span class="line">    public Launcher() &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看下 ServiceLoader.load(service, cl)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    <span class="comment">// ClassLoader.getSystemClassLoader() 获取应用类加载器</span></span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段就不解释了，比较简单，然后就是看 LazyIterator 迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ServiceLoader 的 iterator() 方法最后调用的是这个迭代器里的 next</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据名字来加载类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在 classpath 下查找 META-INF/services/java.sql.Driver 名字的文件夹</span></span><br><span class="line">                <span class="comment">// private static final String PREFIX = "META-INF/services/";</span></span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这里基本就差不多完成整个流程了，一起走一遍：</p>
<p><img src="JDBC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt></p>
<h2 id="3-5-线程上下文类加载器分析"><a href="#3-5-线程上下文类加载器分析" class="headerlink" title="3.5 线程上下文类加载器分析"></a>3.5 线程上下文类加载器分析</h2><p>线程上下文类加载器（Context ClassLoader）：线程上下文类加载器是从 JDK1.2 开始引入的，类 Thread 中 getContextClassLoader 与 setContextClassLoader 方法分别用来获取和设置上下文类加载器。</p>
<p><font color="blue">扩展-1</font>：线程上下文类加载器默认使用应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器</span><br><span class="line">null                                      # 启动类加载器</span><br></pre></td></tr></table></figure>

<p>这里首先要理解类加载中的一个机制，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器 A 加载的（如果该依赖之前没有被加载过的话），什么是指依赖类呢？依赖类是指当前类使用的其它类，将其它类称之为当前类的依赖类。上下文类加载器的作用就是为了破坏 Java 的类加载委托机制。它是怎么实现的呢？其实在<a href="3-4-破坏双亲委派模型的-JDBC-实现案例">3.4 破坏双亲委派模型的 JDBC 实现案例</a>中的代码分析已经有说明，是通过在 Launcher  类的构造方法中设置的。所以上述上下文类加载器的打印结果即应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><font color="blue">扩展-2</font>：线程上下文类加载器的一般使用模式。当高层提供了统一的接口让低层去实现，同时又要在高层加载（或实例化）低层的类时，就必须要通过线程上下文类加载器来帮助高层的类加载器找到并加载该类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 1.设置</span></span><br><span class="line">   Thread.currentThread().setContextClassLoader(targetTccl);</span><br><span class="line">   <span class="comment">// 2.使用</span></span><br><span class="line">   myMethod();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 3.还原</span></span><br><span class="line">   Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">扩展-3</font>：MySQL 驱动实现类的加载。</p>
<p>添加 mysql-connector-java 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载驱动</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Driver driver = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver: "</span> + driver.getClass() + <span class="string">", loader: "</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前线程上下文类加载器："</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader 的类加载器："</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">当前线程上下文类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">ServiceLoader 的类加载器：null # 位于 rt.jar 包中属于启动类加载器加载</span><br></pre></td></tr></table></figure>

<p><font color="red">JVM 是怎么可以通过一个 Driver 接口就找到具体的实现类呢？</font>ServiceLoader 类的文档说明：</p>
<p><img src="ServiceLoader%E5%8A%A0%E8%BD%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png" alt></p>
<p>我们可以在 mysql-connector-java-5.1.47.jar 文件下找到对应 ServiceLoader 类的文档中描述的配置信息，也就知道了上述打印结果的 Driver 接口实现类从何而来。</p>
<p><img src="MySQL%E7%9A%84Driver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png" alt></p>
<h2 id="3-6-自定义类加载器"><a href="#3-6-自定义类加载器" class="headerlink" title="3.6 自定义类加载器"></a>3.6 自定义类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest16</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将应用类加载器当做该类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyTest16&#123;"</span> +</span><br><span class="line">                <span class="string">"classLoaderName='"</span> + classLoaderName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">"findClass invoked: "</span> + className); <span class="comment">// 验证是否使用我们自定义的类加载器</span></span><br><span class="line">        System.out.println(<span class="string">"class loader name: "</span> + <span class="keyword">this</span>.classLoaderName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">this</span>.loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        className = className.replace(<span class="string">"."</span>, <span class="string">"\\"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + className + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((ch = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">        <span class="comment">// 从默认的文件夹下进行加载</span></span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        System.out.println(object1);</span><br><span class="line">        System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line">        <span class="comment">// 从默认的文件夹下进行加载</span></span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class2: "</span> + clazz2.hashCode());</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        System.out.println(object2.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class1: 460141958</span><br><span class="line">MyTest15</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">class2: 460141958</span><br><span class="line">MyTest15</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>根据以上的执行结果，可见并没有使用我们自定义的类加载器进行加载，而是由应用类加载器所加载的，这是为什么？因为我们自己所定义的类加载器是将应用类加载器所加载作为父类加载器，根据双亲委派模型可知是由我们自定义类加载器的父类加载器，即应用类加载器所加载。而且因为 loader1 与 loader2 都是同一个父类加载器所以 class1.hashCode 与 class2.hashCode 的值是一样的。</p>
<p>接下来对上述 main 方法进行修改下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line"><span class="comment">// 从指定的文件夹下进行加载</span></span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">Object object = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line"><span class="comment">// 从指定的文件夹下进行加载</span></span><br><span class="line">loader2.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class2: "</span> + clazz2.hashCode());</span><br><span class="line">Object object2 = clazz2.newInstance();</span><br><span class="line">System.out.println(object2);</span><br><span class="line">System.out.println(object2.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：执行前在将原有默认路径下的 MyTest15.class 文件拷贝至指定的路径下的同时，必须将原有路径下的 MyTest15.class 文件删除，如果不删除，执行结果与之前一样，因为 loader1 与 loader2 同属同一个父类加载器，即应用类加载器，而应用类加载器默认是加载用户类路径 ClassPath 上所指定的类，因此要想验证自定义类加载器必须删除 MyTest15.class 文件。</p>
</blockquote>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8MyTest16.png" alt></p>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 1956725890</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line"></span><br><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader2</span><br><span class="line">class2: 21685669</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader2&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>可见，我们自定义的类加载器生效了，那么为什么 class1.hashCode 与 class2.hashCode 不一致呢？这里涉及到<font color="red">类加载器的命名空间</font>问题。</p>
<div class="note danger">
            <p>1）每个类加载器都有自己的命名空间，命名空间由<font color="red">该加载器及所有父类加载器</font>所加载的类组成。<br>2）在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。<br>3）在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
          </div>

<p>接下来，我们继续对代码进行改造，只需修改下面一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上述代码中的构造方法中添加 loader1 作为父类加载器。</span></span><br><span class="line"> MyTest16 loader2 = <span class="keyword">new</span> MyTest16(loader1, <span class="string">"loader2"</span>);</span><br></pre></td></tr></table></figure>

<p>注意执行前保证当前用户类路径下没有 MyTest15.class 文件，即删除 C:\Users\westboy\IdeaProjects\jvm-learning\shengsiyuan-jvm\target\classes\ 下的 MyTest15.class 文件，并且保存到指定路径，执行后结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: <span class="number">1956725890</span></span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=<span class="string">'loader1'</span>&#125;</span><br><span class="line"></span><br><span class="line">class2: <span class="number">1956725890</span></span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=<span class="string">'loader1'</span>&#125;</span><br></pre></td></tr></table></figure>


<p>分析：loader1 初次加载 MyTest15，委托给父类加载器，即应用类加载器，但是当前用户类路径下没有 MyTest15.class 文件（被我们删除了），所以 loader1 自己去使用我们自定义的类加载器去加载，并加载成功。当 loader2 进行继续加载时，因为其父类加载器被指定为 loader1，而 loader1 已经加载了 MyTest15，所以 class1.hashCode 与 class2.hashCode 相同。</p>
<div class="note danger">
            <p>类加载器命名空间扩展：同一个命名空间内的类是相互可见的。<font color="red">子类加载器的命名空间包含所有父类加载器的命名空间，因此子类加载器所加载的类能够访问父类加载器所加载的类。而由父类加载器所加载的类无法访问子类加载器所加载的类</font>。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。</p>
          </div>

<p>接下来，予以验证。</p>
<p><strong><font color="blue">验证第一阶段：基础夯实阶段</font></strong></p>
<p>先添加两个示例类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// MySample 中主动引用 MyCat。</span></span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本示例的用户当前类路径：C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\，指定路径为：D:\\jvm\\。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用上述自定义类加载器加载类。</span></span><br><span class="line">    MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">    loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"com.westboy.MySample"</span>);</span><br><span class="line">    System.out.println(<span class="string">"class: "</span> + clazz.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果注释掉该行，那么并不会实例化 MySample 对象，即 MySample 构造方法不会被调用，</span></span><br><span class="line">    <span class="comment">// 因此不会实例化 MyCat 对象，即没有对 MyCat 进行主动使用，这里就不会加载 MyCat Class。</span></span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>MySample 与 MyCat 类都是应用类加载器进行加载，前面内容已经解释的很清楚，不用赘述。</p>
<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/westboy/MyCat</span><br><span class="line">  at com.westboy.MySample.&lt;init&gt;(MySample.java:12)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">  at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">  at com.westboy.MyTest17.main(MyTest17.java:12)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.westboy.MyCat</span><br><span class="line">  at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">  at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">  ... 7 more</span><br></pre></td></tr></table></figure>

<p>MyCat 类加载是由加载了 MySample 类的类加载器，即应用加载器所尝试加载，但是由于用户当前类路径下的 MySample.class 文件已经被删除，所以找不到，就抛出异常。</p>
<p><font color="blue">情况-3</font>：只删除用户当前类路径下的 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>MySample 类由用户自定义加载器进行加载，是因为在双亲委派模型下，其父类加载器，即应用类加载器在当前用户路径下找不到 MySample.class 文件，所以由自定义类加载器去加载。而 MyCat 类的加载，在其父类加载器，即应用类加载器在当前用户路径下可以找到 MyCat.class 文件，所以由应用类加载器所加载。</p>
<p><font color="blue">情况-4</font>：删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">findClass invoked: com.westboy.MyCat</span><br><span class="line">class loader name: loader1</span><br><span class="line">MyCat is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>MySample 与 MyCat 类都是用户自定义加载器进行加载，前面内容已经解释的很清楚，不用赘述。</p>
<p><strong><font color="blue">验证第二阶段：父类无法访问子类</font></strong></p>
<p>修改 MyCat 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());、</span><br><span class="line">        System.out.println(<span class="string">"from MyCat: "</span> + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MyCat: class com.westboy.MySample</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/westboy/MySample</span><br><span class="line">  at com.westboy.MyCat.&lt;init&gt;(MyCat.java:6)</span><br><span class="line">  at com.westboy.MySample.&lt;init&gt;(MySample.java:12)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">  at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">  at com.westboy.MyTest17.main(MyTest17.java:12)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.westboy.MySample</span><br><span class="line">  at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">  at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">  ... 8 more</span><br></pre></td></tr></table></figure>

<p>分析结果：MySample 类由自定义类加载器加载，MyCat 类由应用类加载器加载，而应用类加载器加载是自定义类加载器加载的父类加载器，所以根据类加载器的命名空间的内容得知，父类加载器是访问不到子类加载器所加载的类。所以在由父类加载器所加载的 MyCat 类去访问由子类加载器所加载的 MySample 类时是访问不到的，因此抛出异常。</p>
<p><strong><font color="blue">验证第三阶段：子类可以访问父类</font></strong></p>
<p>MyCat 还原至第一阶段，修改 MySample 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MySample: class com.westboy.MyCat</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MySample: class com.westboy.MyCat</span><br></pre></td></tr></table></figure>

<p>分析结果：MySample 类由自定义类加载器加载，MyCat 类由应用类加载器加载，而应用类加载器加载是自定义类加载器加载的父类加载器，所以根据类加载器的命名空间的内容得知，子类加载器是可以访问父类加载器所加载的类。所以在由子类加载器所加载的 MySample 类中去访问由父类加载器所加载的 MyCat 类时是可以访问的，因此可以正常访问，并不会抛出异常。</p>
<p><strong><font color="blue">验证第四阶段：两个之间没有直接或间接的父子关系的加载器相互不可见</font></strong></p>
<p>创建示例类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyPerson myPerson;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处为什么设置参数为 Object？原因见下代码中的分析。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object Object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myPerson = (MyPerson) Object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">    MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line"></span><br><span class="line">    loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">    loader2.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyPerson"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyPerson"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">    Object object1 = clazz1.newInstance();</span><br><span class="line">    Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 MyPerson 类的 setMyPerson 的传参类型设置为 MyPerson，此处修改传参类型为 MyPerson.class，在运行时就会抛出异常：NoClassDefFoundError，</span></span><br><span class="line">    <span class="comment">// 因为此处为应用类加载器去加载 MyPerson 类，又因为我们已经删除了当前用户类路径下的 MyPerson.class 文件，所以就会抛出异常。</span></span><br><span class="line">    <span class="comment">// 这就是为什么 MyPerson 的 setMyPerson 方法传参设置为 Object 的奥妙。</span></span><br><span class="line">    Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object.class);</span><br><span class="line">    method.invoke(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前用户类路径下的 MyPerson.class 文件<font color="red">剪切</font>至指定类路径下，并执行，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyPerson</span><br><span class="line">class loader name: loader1</span><br><span class="line">findClass invoked: com.westboy.MyPerson</span><br><span class="line">class loader name: loader2</span><br><span class="line">false</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">  at com.westboy.MyTest21.main(MyTest21.java:23)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.westboy.MyPerson cannot be cast to com.westboy.MyPerson</span><br><span class="line">  at com.westboy.MyPerson.setMyPerson(MyPerson.java:8)</span><br><span class="line">  ... 5 more</span><br></pre></td></tr></table></figure>

<p>将会发下一个奇怪的错误：<font color="red">com.westboy.MyPerson</font> cannot be cast to <font color="red">com.westboy.MyPerson</font>。为什么呢？看看标题，仔细分析。</p>
<h1 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4 类的卸载"></a>4 类的卸载</h1><p>当类被加载、连接和初始化后，它的生命周期就开始了。当代表类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，类在方法区内数据也会被卸载，从而结束类的生命周期。</p>
<p><font color="red">一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期</font>。</p>
<p><font color="red">由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载</font>。前面已经介绍过，Java 虚拟机自带的类加载器包括启动类加载器、扩展类加载器和应用/系统类加载器。Java 虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的 Class 对象，因此这些 Class 对象始终是可触及的。<br><font color="red">由用户自定义的类加载器所加载的类是可以被卸载的</font>。</p>
<p>类的卸载示例，修改之前使用的例子，并添加 VM 参数：-XX:+TraceClassUnloading，打印类的卸载信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">Object object1 = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">loader1 = <span class="keyword">null</span>;</span><br><span class="line">clazz1 = <span class="keyword">null</span>;</span><br><span class="line">object1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">object1 = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 1956725890</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line"></span><br><span class="line">[Unloading class com.westboy.MyTest15 0x00000007c0061028]</span><br><span class="line"></span><br><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 21685669</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过 Java 自带的 VisualVM 工具观察到，在观察之前将代码稍微修改下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">loader1 = <span class="keyword">null</span>;</span><br><span class="line">clazz1 = <span class="keyword">null</span>;</span><br><span class="line">object1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 让程序保持运行</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>VisualVM 监控信息：</p>
<p><img src="%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD%E7%9B%91%E6%8E%A7%E7%A4%BA%E4%BE%8B.png" alt></p>
<h1 id="5-Jar-Hell-问题及诊断"><a href="#5-Jar-Hell-问题及诊断" class="headerlink" title="5 Jar Hell 问题及诊断"></a>5 Jar Hell 问题及诊断</h1><p>当一个类或者一个资源文件存在多个 Jar 中，就会存在 Jar Hell 问题。</p>
<p>可以通过以下代码来诊断问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">String reosurceName = <span class="string">"xxx.class"</span>;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(reosurceName);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/26/JVM-03-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" rel="next" title="JVM-03-类文件结构">
                  <i class="fa fa-chevron-left"></i> JVM-03-类文件结构
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2019/11/26/JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/" rel="prev" title="JVM-05-垃圾收集实战分析与调优">
                  JVM-05-垃圾收集实战分析与调优 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-类的加载过程"><span class="nav-text">1 类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-类的生命周期"><span class="nav-text">1.1 类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-主动引用"><span class="nav-text">1.2 主动引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-被动引用"><span class="nav-text">1.3 被动引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-类的加载"><span class="nav-text">1.4 类的加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-连接-验证"><span class="nav-text">1.5 连接-验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-连接-准备"><span class="nav-text">1.6 连接-准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-连接-解析"><span class="nav-text">1.7 连接-解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-初始化"><span class="nav-text">1.8 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-实战"><span class="nav-text">1.9 实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-1-子类与父类中静态字段的加载与初始化"><span class="nav-text">1.9.1 子类与父类中静态字段的加载与初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-2-编译期常量所在类的初始化"><span class="nav-text">1.9.2 编译期常量所在类的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-3-非编译期常量所在类的初始化"><span class="nav-text">1.9.3 非编译期常量所在类的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-4-数组实例的类型创建时机"><span class="nav-text">1.9.4 数组实例的类型创建时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-5-接口相关的初始化"><span class="nav-text">1.9.5 接口相关的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-6-初始化阶段分析"><span class="nav-text">1.9.6 初始化阶段分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-类加载器"><span class="nav-text">3 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-类与类加载器"><span class="nav-text">3.1 类与类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-类的加载机制"><span class="nav-text">3.2 类的加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-双亲委派模型"><span class="nav-text">3.2 双亲委派模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-破坏双亲委派模型（TODO-简化）"><span class="nav-text">3.3 破坏双亲委派模型（TODO 简化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-破坏双亲委派模型的-JDBC-实现案例"><span class="nav-text">3.4 破坏双亲委派模型的 JDBC 实现案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-线程上下文类加载器分析"><span class="nav-text">3.5 线程上下文类加载器分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-自定义类加载器"><span class="nav-text">3.6 自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-类的卸载"><span class="nav-text">4 类的卸载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Jar-Hell-问题及诊断"><span class="nav-text">5 Jar Hell 问题及诊断</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="王鹏博"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">王鹏博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王鹏博</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
