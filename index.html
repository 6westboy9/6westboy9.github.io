<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.2">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.2">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.2" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.2">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","width":300,"display":"post","offset":13,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Westboy&#39;Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Westboy&#39;Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Westboy'Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Westboy'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/26/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-ThreadPoolExecutor/" class="post-title-link" itemprop="url">并发基础-ThreadPoolExecutor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 17:02:04" itemprop="dateCreated datePublished" datetime="2019-11-26T17:02:04+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">并发基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Java 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来 3 个好处。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</li>
</ul>
<h1 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2 生命周期"></a>2 生命周期</h1><p>在 ThreadPoolExecutor 线程池的设计中，把整个任务执行框架线程池划分为 5 个生命周期。参见源码 ThreadPoolExecutor 中的定义：</p>
<figure class="highlight java"><figcaption><span>java.util.concurrent.ThreadPoolExecutor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c &amp; 高 3 位为 1，低 29 位为 0 的 ~CAPACITY，用于获取高 3 位保存的线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// c &amp; 高 3 位为 0，低 29 位为 1 的 CAPACITY，用于获取低 29 位的线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 参数 rs 表示 runState，参数 wc 表示 workerCount，即根据 runState和workerCount 打包合并成 ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前线程池是否正在执行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量 ctl 用于记录线程池中的任务数量和线程状态两个信息，其中<font color=red>高 3 位表示线程池状态，低 29 位表示线程池中的任务数量</font>。</p>
<ul>
<li><font color=red>RUNNING</font>：线程池能够接受新任务，以及对新添加的任务进行处理。</li>
<li><font color=red>SHUTDOWN</font>：线程池不可以接受新任务，但是可以对已添加的任务进行处理。</li>
<li><font color=red>STOP</font>：线程池不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。</li>
<li><font color=red>TIDYING</font>：当所有的任务已终止，ctl 记录的任务数量为 0 时，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行 terminated 钩子方法。terminated 钩子方法在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated 钩子方法来实现。</li>
<li><font color=red>TERMINATED</font>：线程池彻底终止的状态。</li>
</ul>
<p>各个生命周期转化图：</p>
<!-- ![](./线程池状态转换示意图.png) -->

<img src="./线程池状态转换示意图.png" width="500px"/>


<p>从图中可以看到，整个生命周期的变化是<font color=red>不可逆</font>的。</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">高位置枚举</th>
<th>正负性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RUNNING</td>
<td align="center">111</td>
<td>负数（-536870912）</td>
</tr>
<tr>
<td align="center">SHUTDOWN</td>
<td align="center">000</td>
<td>0</td>
</tr>
<tr>
<td align="center">STOP</td>
<td align="center">001</td>
<td>正数（536870912）</td>
</tr>
<tr>
<td align="center">TIDYING</td>
<td align="center">010</td>
<td>正数（1073741824）</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">011</td>
<td>正数（1610612736）</td>
</tr>
</tbody></table>
<p>因此在状态值的排布上可以知道：TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING。</p>
<h1 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h1><p>线程池的主要处理流程：</p>
<!-- ![](线程池状态转换图.png) -->

<img src="线程池执行流程图.png" width="650px"/>

<p>ThreadPoolExecutor 执行示意图：</p>
<img src="ThreadPoolExecutor执行示意图.png" width="750px"/>



<p>ThreadPoolExecutor 执行 execute 方法执行过程：</p>
<p>① 如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。<br>② 如果当前运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。<br>③ 如果无法将任务加入 BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。<br>④ 如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler 的 rejectedExecution 方法。</p>
<p>ThreadPoolExecutor 采取上述步骤的总体设计思路，是为了在执行 execute() 方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在 ThreadPoolExecutor 完成预热之后（当前运行的线程数大于等于 corePoolSize），几乎所有的 execute() 方法调用都是执行步骤 2，而<font color=red>步骤 2 不需要获取全局锁</font>。</p>
<h1 id="4-线程池的使用"><a href="#4-线程池的使用" class="headerlink" title="4 线程池的使用"></a>4 线程池的使用</h1><h2 id="4-1-创建线程池"><a href="#4-1-创建线程池" class="headerlink" title="4.1 创建线程池"></a>4.1 创建线程池</h2><p>我们可以通过 ThreadPoolExecutor 来创建一个线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">                         </span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下创建一个线程池时需要填入几个重要参数的含义及其作用。</p>
<h3 id="①-线程池大小"><a href="#①-线程池大小" class="headerlink" title="① 线程池大小"></a>① 线程池大小</h3><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程，等到需要执行的任务数大于核心线程池大小（corePoolSize）时就不再创建。<font color =red>如果调用了线程池的 prestartAllCoreThreads 方法，线程池会提前创建并启动所有核心线程</font>，类似的 prestartCoreThread 方法可以单独启动一个核心线程，如果所有核心线程都已启动，则此方法将返回 false。</p>
<p>线程池允许创建的最大线程数（maximumPoolSize）。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是， <font color =red>如果使用了无界的任务队列最大线程数（maximumPoolSize）就不再发挥作用</font>。</p>
<h3 id="②-存活时间"><a href="#②-存活时间" class="headerlink" title="② 存活时间"></a>② 存活时间</h3><p>空闲线程的存活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了。注意这个值<font color =red>并不会对所有线程起作用</font>，如果线程池中的线程数少于等于核心线程数，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 allowCoreThreadTimeOut(true) 使核心线程数内的线程也可以被回收。</p>
<h3 id="③-阻塞队列"><a href="#③-阻塞队列" class="headerlink" title="③ 阻塞队列"></a>③ 阻塞队列</h3><p>用于保存等待执行的任务的阻塞队列。可以选择的阻塞队列参见：<a href="">Java-集合-03-Queue</a>。</p>
<h3 id="④-线程工厂"><a href="#④-线程工厂" class="headerlink" title="④ 线程工厂"></a>④ 线程工厂</h3><p>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架 guava 提供的 ThreadFactoryBuilder 可以快速给线程池里的线程设置有意义的名字，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</span><br></pre></td></tr></table></figure>

<h3 id="⑤-拒绝策略"><a href="#⑤-拒绝策略" class="headerlink" title="⑤ 拒绝策略"></a>⑤ 拒绝策略</h3><p>当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。在 JDK 1.5 中 Java 线程池框架提供了以下 4 种策略，以及扩展的第三方自定义拒绝策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>1）AbortPolicy（中止策略）</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是中断当前执行流程。</p>
<p>使用场景：没有需要注意的特殊场景，但是一点，要正确处理抛出的异常。ThreadPoolExecutor 中默认的策略就是 AbortPolicy，ExecutorService 接口的系列 ThreadPoolExecutor 因为都没有显示的设置拒绝策略，所以默认的都是 AbortPolicy。但是请注意，ExecutorService 中的线程池中的队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会中断当前的执行流程。</p>
<p><font color=red>2）CallerRunsPolicy（调用者运行策略）</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。</p>
<p>使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。</p>
<p><font color=red>3）DiscardOldestPolicy（弃老策略）</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">     * and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：如果线程池未关闭，丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾。</p>
<p>使用场景：这个策略会丢弃任务，但是特点是丢弃的是最老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，可以想到的使用场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。</p>
<p><font color=red>4）DiscardPolicy（丢弃策略）</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：直接静悄悄的丢弃这个任务，不触发任何动作。</p>
<p>使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。</p>
<p><font color=red>5）Dubbo 拒绝策略：AbortPolicyWithReport</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicyWithReport</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span>.<span class="title">AbortPolicy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbortPolicyWithReport.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPrintTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore guard = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicyWithReport</span><span class="params">(String threadName, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        String msg = String.format(<span class="string">"Thread pool is EXHAUSTED!"</span> +</span><br><span class="line">                        <span class="string">" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),"</span> +</span><br><span class="line">                        <span class="string">" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!"</span>,</span><br><span class="line">                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),</span><br><span class="line">                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),</span><br><span class="line">                url.getProtocol(), url.getIp(), url.getPort());</span><br><span class="line">        logger.warn(msg);</span><br><span class="line">        dumpJStack();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpJStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 省略实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当 Dubbo 的工作线程触发了线程拒绝后，主要做了三个事情，原则就是尽量让使用者清楚触发线程拒绝策略的真实原因。</p>
<p>第一，输出了一条警告级别的日志，日志内容为线程池的详细设置参数，以及线程池当前的状态，还有当前拒绝任务的一些详细信息。可以说，这条日志，使用 Dubbo 的有过生产运维经验的或多或少是见过的，这个日志简直就是日志打印的典范，其他的日志打印的典范还有 Spring。得益于这么详细的日志，可以很容易定位到问题所在。<br>第二，输出当前线程堆栈详情，这个太有用了，当你通过上面的日志信息还不能定位问题时，案发现场的 dump 线程上下文信息就是你发现问题的救命稻草，这个可以参考：<a href="http://www.kailing.pub/article/index/arcid/212.html" target="_blank" rel="noopener">《Dubbo 线程池耗尽事件-“CyclicBarrier 惹的祸”》</a>。<br>第三，继续抛出异常，使本次任务失败，继承了 JDK 默认拒绝策略的特性。</p>
<p><font color=red>6）Netty 拒绝策略：NewThreadRunsPolicy</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThreadRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    NewThreadRunsPolicy() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread(r, <span class="string">"Temporary task executor"</span>);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Failed to start a new thread"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 中的实现很像 JDK 中的 CallerRunsPolicy，舍不得丢弃任务。不同的是，CallerRunsPolicy 是直接在调用者线程执行的任务。而 Netty 是新建了一个线程来处理的。所以，Netty 的实现就可以扩展到支持高效率高性能的场景了。但是也要注意一点，Netty 的实现里，在创建线程时未做任何的判断约束，也就是说只要系统还有资源就会创建新的线程来处理，直到创建不了新的线程，才会抛创建线程失败的异常。</p>
<p>当然，也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。</p>
<h2 id="4-2-提交任务"><a href="#4-2-提交任务" class="headerlink" title="4.2 提交任务"></a>4.2 提交任务</h2><p>可以使用两个方法向线程池提交任务，分别为 execute 和 submit 方法。其中 submit 方法为抽象类 AbstractExecutorService 中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// TODO           </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>submit 方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-关闭线程池"><a href="#4-3-关闭线程池" class="headerlink" title="4.3 关闭线程池"></a>4.3 关闭线程池</h2><p>可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以<font color=red>无法响应中断的任务可能永远无法终止</font>。</p>
<div class="note warning">
            <p><font color=red>区别</font>：shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。</p>
          </div>

<p>只要调用了这两个关闭方法中的任意一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 方法来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow 方法。</p>
<h2 id="4-4-合理配置线程池"><a href="#4-4-合理配置线程池" class="headerlink" title="4.4 合理配置线程池"></a>4.4 合理配置线程池</h2><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<ul>
<li>任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。</li>
<li>任务的优先级：高、中和低。</li>
<li>任务的执行时间：长、中和短。</li>
<li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li>
</ul>
<p>性质不同的任务可以用不同规模的线程池分开处理。CPU 密集型任务应配置尽可能小的线程，如配置 Ncpu+1 个线程的线程池。由于 IO 密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2×Ncpu。混合型的任务，如果可以拆分，将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 Runtime.getRuntime().availableProcessors() 方法获得当前设备的 CPU 个数。</p>
<p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先执行。注意：<font color=red>如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行</font>。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，等待的时间越长，则 CPU 空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用 CPU。</p>
<p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力。</p>
<h2 id="4-5-钩子方法"><a href="#4-5-钩子方法" class="headerlink" title="4.5 钩子方法"></a>4.5 钩子方法</h2><p>ThreadPoolExecutor 中主要提供以下三个钩子方法，这三个方法都是 protected 的空方法以便扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>在执行任务的线程中将调用 beforeExecute 和 afterExecute 方法，在这些方法中还可以添加日志、计时、监视或者统计信息收集的功能。</p>
<ul>
<li>无论任务是从 run 方法中正常返回，还是抛出一个异常而返回，afterExecute 都会被调用。</li>
<li>如果任务在完成后带有一个 Error，那么就不会调用 afterExecute。</li>
<li>如果 beforeExecute 抛出一个 RuntimeException，那么任务将不被执行，并且 afterExecute 也不会被调用。</li>
</ul>
<!-- > 注意：要正确嵌套多个重叠，子类通常应在此方法结束时调用 super.beforeExecute 和 super.afterExecute。 -->

<p>在线程池完成关闭时调用 terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后，terminated 可以用来释放 Executor 在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志等操作。关于钩子方法的应用实战，参见：<a href="https://blog.csdn.net/u013256816/article/details/50403962" target="_blank" rel="noopener">Java 多线程之扩展 ThreadPoolExecutor</a>。</p>
<p>借助钩子方法下面的 PausableThreadPoolExecutor 是官方文档中提供的一个简单的支持可暂停/恢复的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-线程池的监控"><a href="#4-6-线程池的监控" class="headerlink" title="4.6 线程池的监控"></a>4.6 线程池的监控</h2><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性或方法。</p>
<ul>
<li>taskCount 属性：线程池需要执行的任务数量。</li>
<li>completedTaskCount 属性：线程池在运行过程中已完成的任务数量，小于或等于 taskCount。</li>
<li>largestPoolSize 属性：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li>getPoolSize 方法：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount 方法：获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute 和 terminated 方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。</p>
<blockquote>
<p><a href="https://my.oschina.net/dabird/blog/1527867" target="_blank" rel="noopener">扩展 ThreadPoolExecutor 实现线程池监控</a></p>
</blockquote>
<h2 id="4-7-使用原则"><a href="#4-7-使用原则" class="headerlink" title="4.7 使用原则"></a>4.7 使用原则</h2><blockquote>
<p><a href="https://dwz.cn/CQiYTbxz" target="_blank" rel="noopener">谈谈线程池使用原则</a></p>
</blockquote>
<h1 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5 源码分析"></a>5 源码分析</h1><h2 id="5-1-任务提交方法"><a href="#5-1-任务提交方法" class="headerlink" title="5.1 任务提交方法"></a>5.1 任务提交方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 返回 ture 添加任务成功，那么就结束了，线程池已经接受了这个任务，这个方法也就可以返回了，至于执行的结果，到时候会包装到 FutureTask 中</span></span><br><span class="line">        <span class="comment">// 返回 false 代表线程池不允许提交任务</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span></span><br><span class="line">    <span class="comment">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 再次检查线程池状态，如果不是 RUNNING 状态，将先前加入队列的任务移除，并执行拒绝策略</span></span><br><span class="line">        <span class="comment">// 再次检查的目的：防止任务提交到队列中了，但线程池关闭了，所以再进行一次线程池状态检查</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果线程池还是 RUNNING 的，并且运行中的线程数为 0，则开启新的线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 workQueue 队列满了，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-添加任务核心方法"><a href="#5-2-添加任务核心方法" class="headerlink" title="5.2 添加任务核心方法"></a>5.2 添加任务核心方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否可以根据当前池状态和给定边界（核心或最大）添加新工作线程</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 第一个参数是准备提交给这个线程执行的任务，可以为 null</span></span><br><span class="line"><span class="comment">// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span></span><br><span class="line"><span class="comment">// 如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment">// 如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等效于：if (rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty()))</span></span><br><span class="line">        <span class="comment">// 满足以下条件之一，不会创建新的 worker（线程池状态大于 SHUTDOWN，也就是 STOP, TIDYING, 或 TERMINATED）：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态等于 SHUTDOWN 且 firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态等于 SHUTDOWN 且 firstTask == null 且 workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 所以当线程池状态等于 SHUTDOWN 且 firstTask == null 且 !workQueue.isEmpty() 时是可以创建新的 worker</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取工作线程数目</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               </span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了，外循环直接结束</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">               </span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 判断是否有其他线程的操作导致线程池的状态发生了变更，如果有，内循环跳出，外循环继续</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述为创建新的 worker 前的校验过程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 添加时全局锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 Worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，Worker 的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当获取全局锁之后再次检查线程池状态，目的：ThreadFactory 退出失败或在获取锁定之前线程池关闭</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是正常的情况</span></span><br><span class="line">                <span class="comment">// 前面说了，如果等于 SHUTDOWN 且 firstTask == null 且 !workQueue.isEmpty() 时是可以创建新的 worker</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 预先检查 worker 关联的 t 线程是否处于活动状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 添加 worker 至 workers，workers 的类型为 HashSet&lt;Worker&gt;</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值，因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 当线程池状态为以下几种状态时，直接返回，不会进一步执行线程池关闭动作</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态是 RUNNING</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态为 TIDYING 或者 TERMINATED</span></span><br><span class="line">        <span class="comment">// 3. 线程池状态为 RUNNING 或者 SHUTDOWN 且 !workQueue.isEmpty()</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateLessThan(c, STOP) &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 工作线程数不为 0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 中断等待 worker</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当线程池状态被设置为 TIDYING 时，执行钩子方法 terminated</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法执行完成，线程池状态被设置为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-任务运行方法"><a href="#5-3-任务运行方法" class="headerlink" title="5.3 任务运行方法"></a>5.3 任务运行方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环调用 getTask 获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 确保只有在线程池为 STOP、TIDYING 或者 TERMINATED 时，才会被设置中断标示，否则清除中断标示</span></span><br><span class="line">            <span class="comment">// 线程池状态为 STOP、TIDYING 或者 TERMINATED 时，且当前线程没有设置中断状态</span></span><br><span class="line">            <span class="comment">// 线程池状态为 RUNNING 或者 SHUTDOWN 时，但 Thread.interrupted() 为 true，即线程已经被中断，又清除了中断标示，</span></span><br><span class="line">            <span class="comment">// 再次判断线程池状态是否为 STOP、TIDYING 或者 TERMINATED，是，再次设置中断标示，wt.interrupt()；否，不做操作，清除中断标示后进行后续步骤</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">                &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                <span class="comment">// 设置线程中断</span></span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行前（子类实现）</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">// 执行后（子类实现）</span></span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 执行后（子类实现）</span></span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 worker 的退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-获取任务方法"><a href="#5-4-获取任务方法" class="headerlink" title="5.4 获取任务方法"></a>5.4 获取任务方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对线程池状态的判断，两种情况会 workerCount-1，并且返回 null</span></span><br><span class="line">        <span class="comment">// 线程池状态为 SHUTDOWN，且 workQueue 为空（反映了 SHUTDOWN 状态的线程池还是要执行 workQueue 中剩余的任务的）</span></span><br><span class="line">        <span class="comment">// 线程池状态为 STOP、TIDYING 或 TERMINATED（shutdownNow()  会导致变成 STOP）（此时不用考虑 workQueue 的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> timed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层循环，要么 break 去 workQueue 获取任务，要么超时了，workerCount-1</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// allowCoreThreadTimeOut 默认为 false</span></span><br><span class="line">            <span class="comment">// 如果 allowCoreThreadTimeOut 为 true，说明 corePoolSize 和 maximumPoolSize 都需要定时</span></span><br><span class="line">            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 如果当前执行线程数 &lt;= maximumPoolSize，并且 timedOut 和 timed 任一为 false，跳出循环，开始从 workQueue 获取任务</span></span><br><span class="line">            <span class="comment">// 等效于 wc &lt;= maximumPoolSize &amp;&amp; (!timedOut || !timed)</span></span><br><span class="line">            <span class="keyword">if</span> (wc &lt;= maximumPoolSize &amp;&amp; !(timedOut &amp;&amp; timed))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行到这一步的条件为：wc &gt; maximumPoolSize || (timedOut &amp;&amp; timed)</span></span><br><span class="line">            <span class="comment">// 如果到了这一步，说明要么线程数量超过了 maximumPoolSize（可能 maximumPoolSize 被修改了）</span></span><br><span class="line">            <span class="comment">// 要么既需要计时 timed==true，也超时了，workerCount-1，然后返回null，在 runWorker() 中会有逻辑减少 worker 线程</span></span><br><span class="line">            <span class="comment">// 如果本次减一失败，继续内层循环再次尝试减一</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果减数量失败，再次读取ctl</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 如果线程池运行状态发生变化，继续外层循环，如果状态没变，继续内层循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// poll() - 使用 LockSupport.parkNanos(this, nanosTimeout) 挂起一段时间，interrupt() 时不会抛异常，但会有中断响应</span></span><br><span class="line">            <span class="comment">// take() - 使用 LockSupport.park(this) 挂起，interrupt() 时不会抛异常，但会有中断响应</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 如获取到了任务就返回</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有返回，说明超时，那么在下一次内层循环时会进入 workerCount 减一的步骤</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 响应中断，重新开始，中断状态会被清除</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-处理任务退出方法"><a href="#5-5-处理任务退出方法" class="headerlink" title="5.5 处理任务退出方法"></a>5.5 处理任务退出方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是突然终止，说明是 task 执行时异常情况导致，即 run() 方法执行时发生了异常，那么 workerCount-1</span></span><br><span class="line">    <span class="comment">// 如果不是突然终止，说明是 worker 线程没有 task 可执行了，不用 -1，因为已经在 getTask() 方法中已经 -1 了</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把 worker 的完成任务数加到线程池的完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从 HashSet&lt;Worker&gt; 中移除</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要增加 worker 线程：</span></span><br><span class="line"><span class="comment">     * 线程池状态是 RUNNING 或 SHUTDOWN，如果当前线程是突然终止的，则需要增加 worker 线程</span></span><br><span class="line"><span class="comment">     * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，则需要增加 worker 线程</span></span><br><span class="line"><span class="comment">     * 故如果调用线程池 shutdown()，直到 workQueue 为空前，线程池都会维持 corePoolSize 个线程（当然 allowCoreThreadTimeOut=false），然后再逐渐销毁这 corePoolSize 个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-关闭线程池"><a href="#5-6-关闭线程池" class="headerlink" title="5.6 关闭线程池"></a>5.6 关闭线程池</h2><figure class="highlight java"><figcaption><span>java.util.concurrent.ThreadPoolExecutor#shutdown</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断空闲 worker 操作</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 留作 ScheduledThreadPoolExecutor 的钩子方法</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// getState() &gt;= 0 所有 worker</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>java.util.concurrent.ThreadPoolExecutor#shutdownNow</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有 worker 操作</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 转移任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// w.tryLock() 所有空闲 worker</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-7-等待线程池终止【TODO】"><a href="#5-7-等待线程池终止【TODO】" class="headerlink" title="5.7 等待线程池终止【TODO】"></a>5.7 等待线程池终止【TODO】</h2><h1 id="6-扩展知识【TODO】"><a href="#6-扩展知识【TODO】" class="headerlink" title="6 扩展知识【TODO】"></a>6 扩展知识【TODO】</h1><h2 id="6-1-Tomcat-中对-ThreadPoolExecutor-的重写"><a href="#6-1-Tomcat-中对-ThreadPoolExecutor-的重写" class="headerlink" title="6.1 Tomcat 中对 ThreadPoolExecutor 的重写"></a>6.1 Tomcat 中对 ThreadPoolExecutor 的重写</h2><!-- * 核心线程会关闭吗？在读完源码之后，可以确定的是核心线程是可以关闭的。
* 为什么 shutdown() 不能中断正在运行中的任务？因为任务运行与中断操作前都需要获取全局锁，所以当任务正在运行时，要进行中断操作的前提是必须获取锁，但是正在运行中的任务线程还没有释放锁，所以中断操作不能继续进行。 -->

<!-- # 7 面试问题 -->


<h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7 参考资料"></a>7 参考资料</h1><ul>
<li><a href="https://www.kunzhao.org/blog/2018/02/26/why-thread-state-is-waiting/#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF" target="_blank" rel="noopener">为什么线程处于 WAITING 状态</a></li>
<li><a href="https://juejin.im/post/5aabb948f265da237506a7f5#heading-3" target="_blank" rel="noopener">深入浅出 Java 线程池 ThreadPoolExecutor</a></li>
<li><a href="https://www.cnblogs.com/sxkgeek/p/9343519.html" target="_blank" rel="noopener">Java 线程池的底层实现与使用</a></li>
<li><a href="http://www.cnblogs.com/trust-freedom/p/6594270.html" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 使用和分析(一)</a></li>
<li><a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 使用和分析(二)</a></li>
<li><a href="http://www.cnblogs.com/trust-freedom/p/6693601.html" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 使用和分析(三)</a></li>
<li><a href="http://www.kailing.pub/article/index/arcid/255.html?nsukey=e8g0EYbQeuH9eSPBItVtXWyjnrjau2SZFx%2Bg9%2F7N1MzTBzawzTsm%2BHPYTf2CqWAQ34JMowW4dtMt4GKKKzTXHcnG%2FSX9vEK1YBzncPnY2pISW1737%2BbbY0ZDdC1IrPhx1gxooIoxyWkE%2Fibh59s4gBW1%2FhNxyPZyWZYwTdxZ4I%2Bi%2F0O6L5aANlxuGcFtOjFfhOHvouKzIzgSyzHxAv1srQ%3D%3D" target="_blank" rel="noopener">Java 线程池 ThreadPoolExecutor 八种拒绝策略浅析</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/26/JVM-05-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">JVM-05-垃圾收集实战分析与调优</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 16:58:20" itemprop="dateCreated datePublished" datetime="2019-11-26T16:58:20+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-垃圾收集实战"><a href="#1-垃圾收集实战" class="headerlink" title="1 垃圾收集实战"></a>1 垃圾收集实战</h1><div class="note warning">
            <p>环境：Java HotSpot(TM) 64-Bit Server VM (25.211-b12) </p>
          </div>


<h2 id="1-1-Young-GC"><a href="#1-1-Young-GC" class="headerlink" title="1.1 Young GC"></a>1.1 Young GC</h2><p>Young GC 模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">5242880</span>                 <span class="comment">// 新生代大小 5242880B，即 5MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">5242880</span>              <span class="comment">// 新生代最大大小 5MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">10485760</span>        <span class="comment">// 初始堆大小 10MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">10485760</span>            <span class="comment">// 最大堆大小 10MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.log                      <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>执行示例代码后查看 gc.log 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JVM 信息</span></span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (25.211-b12) for bsd-amd64 JRE (1.8.0_211-b12), built on Apr  1 2019 20:53:18 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 内存信息</span></span><br><span class="line">Memory: 4k page, physical 16777216k(251828k free)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JVM 参数信息</span></span><br><span class="line">/proc/meminfo:</span><br><span class="line">CommandLine flags: -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:MaxNewSize=5242880 -XX:NewSize=5242880 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GC 详细日志信息</span></span><br><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs] 3678K-&gt;329K(9728K), 0.0005871 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> JVM 退出的时候打印出来的当前堆内存的使用情况</span></span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 4608K, used 2418K [0x00000007bf600000, 0x00000007bfb00000, 0x00000007bfb00000)</span><br><span class="line">  eden space 4096K,  51% used [0x00000007bf600000, 0x00000007bf80a558, 0x00000007bfa00000)</span><br><span class="line">  from space 512K,  64% used [0x00000007bfa80000, 0x00000007bfad2640, 0x00000007bfb00000)</span><br><span class="line">  to   space 512K,   0% used [0x00000007bfa00000, 0x00000007bfa00000, 0x00000007bfa80000)</span><br><span class="line"> concurrent mark-sweep generation total 5120K, used 0K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>对于上述日志从中能看来获取到哪些信息呢？接下来结合我们的示例代码一一进行分析。</p>
<p>其实从上面的日志注释中我们可以发现总的分为 5 块内容，对于我们来说最主要的就是<font color="red"> GC 详细日志信息</font>和<font color="red"> JVM 退出的时候打印出来的当前堆内存的使用情况</font>，接下来着重分析下这两块的内容。</p>
<p>首先看下 GC 详细日志信息内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs] 3678K-&gt;329K(9728K), 0.0005871 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p><font color="red">GC (Allocation Failure) 0.071</font>：当要分配内存空间时，Eden 区内存不够，即分配内存失败。0.071 表示的是 GC 发生的时间点，表示系统运行以后过了多少秒发生本次 GC。</p>
<p><font color="red">ParNew: 3678K-&gt;329K(4608K), 0.0005137 secs</font>：通过 ParNew 就明白此次 GC 为新生代的 Young GC，4608K 表示新生代可用空间，即 4.5MB，3678K-&gt;329K 意思是对新生代执行一次 GC，GC 之前新生代占用空间大小为 3678K，GC 之后新生代占用空间大小 329K，表示本次 Young GC 有 329K 的对象存活下来。0.0015632 secs 表示本次 GC 耗时。</p>
<p>新生代可用空间 = Eden + 一个 Survivor = 4MB + 0.5MB = 4.5MB，然后当执行到示例代码第 7 行前，内存中的分布情况见下图：</p>
<img src="YoungGC示例分析1.png" width="450px"/>

<p>Eden 区中已占用三个 1MB 大小的数组，即为 3072KB，但是为什么从日志中显示 GC 前已使用的大小为 3678KB 呢？为什么会多出来的 0.5MB 呢？这是因为分配一个 1MB 数组时实际上 JVM 还会附带一些其他信息，每个数组实际占用大小是大于 1MB 的。</p>
<p>接着在执行示例代码中第 7 行时， Eden 分配一个 2MB 的数组，Eden 的可用空间是不够的，对象分配失败，触发 Young GC，然后 ParNew 执行垃圾回收，回收掉之前我们创建的三个数组，因为它们已经没有被引用了。GC 回收之后从 3678KB 内存使用降低到 329KB，也就是说此次 GC 有 329KB 的对象存活了下来，从 Eden 区转移到 Survivor From 区。</p>
<img src="YoungGC示例分析2.png" width="450px"/>

<p><font color="red">3678K-&gt;329K(9728K), 0.0005871 secs</font>：指的是整个 JVM 堆内存的情况，9728K 表示当前堆内存总的可用空间大小，即新生代的 4.5MB + 老年代的 5MB，3678K 表示 GC 前整个 JVM 堆内存已占用空间大小，329KB 表示 GC 后整个 JVM 堆内存已占用空间大小。</p>
<p><font color="red">Times: user=0.00 sys=0.00, real=0.00 secs</font>：表示本次 GC 消耗的时间，单位为秒。</p>
<p>接着我们看下面的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> par new generation   total 4608K, used 2418K [0x00000007bf600000, 0x00000007bfb00000, 0x00000007bfb00000)</span><br><span class="line">  eden space 4096K,  51% used [0x00000007bf600000, 0x00000007bf80a558, 0x00000007bfa00000)</span><br><span class="line">  from space 512K,  64% used [0x00000007bfa80000, 0x00000007bfad2640, 0x00000007bfb00000)</span><br><span class="line">  to   space 512K,   0% used [0x00000007bfa00000, 0x00000007bfa00000, 0x00000007bfa80000)</span><br><span class="line"> concurrent mark-sweep generation total 5120K, used 0K [0x00000007bfb00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><font color="red">par new generation   total 4608K, used 2418K</font>：表示使用 ParNew 垃圾收集器负责的新生代总共有 4608KB 可用内存，目前已使用 2418KB。</p>
<p>那么为什么在 JVM 退出之前新生代使用了 2418KB 的内存呢？</p>
<p>因为我们后面又分配了一个 2MB 的数组：byte[] array2 = new byte[2 * 1024 * 1024]; ，所以此时在 Eden 区中一定会有一个 2MB 的数组，也就是 2048K，然后上次 GC 之后存活下来 442K 的对象。但此时疑惑 2048KB + 329KB = 2277KB，那么为什么说新生代使用了 2418KB 呢？按照之前的说法，JVM 还有其他一些附带对象的创建。</p>
<img src="YoungGC示例分析3.png" width="450px"/>

<p><font color="red">concurrent mark-sweep generation total 5120K, used 0K</font>：CMS 管理的老年代可用空间大小为 5MB，暂未使用。</p>
<p><font color="red">Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</font>：Metaspace 元数据空间的使用情况。</p>
<p>参考 stackoverflow 的资料：<a href="https://stackoverflow.com/questions/40891433/understanding-metaspace-line-in-jvm-heap-printout" target="_blank" rel="noopener">Understanding metaspace line in JVM heap printout</a>，翻译如下：</p>
<p>在 JDK1.8 版本中取消了 PermGen。取而代之的是 MetaSpace，方法区在 JDK1.8 以后移至 MetaSpace。JDK1.8 开始把类的元数据放到本地内存，称之为 MetaSpace。理论上本地内存剩余多少，MetaSpace 就有多大，当然我们也不可能无限制的增大 MetaSpace，需要用 -XX:MaxMetaSpaceSize 来指定 MetaSpace 区域大小。</p>
<img src="Metaspace元数据空间使用情况.png" width="400px"/>

<p>MetaSpace 由一个或多个虚拟空间组成。虚拟空间是操作系统的连续存储空间，虚拟空间是按需分配的。当被分配时，虚拟空间会向操作系统预留（reserved）空间，但还没有被提交（committed）。MetaSpace 的预留空间是全部虚拟空间的大小。虚拟空间的最小分配单元是 MetaChunk（简称 Chunk）。当新的 Chunk 被分配至虚拟空间时，与 Chunk 相关的内存空间被提交了。MetaSpace 的 committed 指的是所有 Chunk 占有的空间。每个 Chunk 占据空间不同，当一个类加载器被 GC 时，所有与之关联的 Chunk 被释放。这些被释放的 Chunk 被维护在一个全局的释放数组里。MetaSpace 的 capacity 指的是所有未被释放的 Chunk 占据的空间。</p>
<p>这么看 GC 日志发现自己 committed 是 4864K，capacity 4486K。有一部分的 MetaChunk 已经被释放了，代表有类加载器被回收了。</p>
<p><font color="red">class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</font>：Class 空间的使用情况。</p>
<p>关于 Metaspace 与 Class 空间的关系可以参考资料：<a href="https://juejin.im/post/5ca033f5f265da30807fe126" target="_blank" rel="noopener">聊聊 JVM 的 CompressedClassSpace</a>。</p>
<h2 id="1-2-Young-GC-后触发对象进入老年代"><a href="#1-2-Young-GC-后触发对象进入老年代" class="headerlink" title="1.2 Young GC 后触发对象进入老年代"></a>1.2 Young GC 后触发对象进入老年代</h2><p>关于 Young GC 后触发对象进入老年代的时机可以参考“<a href="">JVM-02-垃圾收集器与内存分配策略</a>”中内存分配策略的流程图。</p>
<p>对象进入老年代的 4 个常见的时机：</p>
<ol>
<li>动态年龄判断后进入老年代； </li>
<li>长期存活对象进入老年代；</li>
<li>一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代；</li>
<li>大对象直接进入老年代；</li>
</ol>
<p>以下实战演示上述 4 种常见的进入老年代的时机情形。</p>
<h3 id="1-2-1-动态年龄判断后进入老年代"><a href="#1-2-1-动态年龄判断后进入老年代" class="headerlink" title="1.2.1 动态年龄判断后进入老年代"></a>1.2.1 动态年龄判断后进入老年代</h3><p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">300</span> * <span class="number">1024</span>];  <span class="comment">// 可以修改此处的大小，多次执行观察日志输出</span></span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第一次触发 Young GC</span></span><br><span class="line">        array3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第二次触发 Young GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 次，默认 15 次</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.3.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.3.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.075: [GC (Allocation Failure) 0.075: [ParNew: 8139K-&gt;621K(9216K), 0.0005523 secs] 8139K-&gt;621K(19456K), 0.0006159 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.076: [GC (Allocation Failure) 0.076: [ParNew: 7789K-&gt;0K(9216K), 0.0020209 secs] 7789K-&gt;604K(19456K), 0.0020521 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 604K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代3.png" width="950px"/>

<p>初始分配给 array1 和 array2 的内存空间，其中包括一些辅助的未知对象，当需要给 array3 分配 7MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<img src="模拟长期存活对象直接进入老年代4.png" width="950px"/>

<p>Young GC 之后在 Survivor 区中有 621KB 的存活对象，其中包括 300KB 的 array2 数组对象，和其他 321KB 的未知对象，当需要给 array4 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第二次 Young GC。</p>
<p>因为第一次 Young GC 之后存在于 Survivor 区中的存活对象占用空间已经超过 Survivor 区的 50%，并且这些存活对象在此之前已经躲过了第一次 GC，所以在第二次 Young GC 的时候，如果在 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</p>
<p>当调整 array3 为 128KB 时，观察日志结果又有什么不同呢？</p>
<p>查看 gc.3.log 日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.075: [GC (Allocation Failure) 0.075: [ParNew: 7967K-&gt;450K(9216K), 0.0004673 secs] 7967K-&gt;450K(19456K), 0.0005300 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.076: [GC (Allocation Failure) 0.076: [ParNew: 7618K-&gt;528K(9216K), 0.0003850 secs] 7618K-&gt;528K(19456K), 0.0004124 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2822K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  28% used [0x00000007bec00000, 0x00000007bee3d8a0, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  51% used [0x00000007bf400000, 0x00000007bf484250, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到由于没有达到动态年龄判断指定的的规则，所以只是一次平常的 Young GC，并没有存活对象进入老年代。</p>
<h3 id="1-2-2-长期存活对象进入老年代"><a href="#1-2-2-长期存活对象进入老年代" class="headerlink" title="1.2.2 长期存活对象进入老年代"></a>1.2.2 长期存活对象进入老年代</h3><p>接着上述的演示，我们可以稍加调整就可以演示长期存活对象进入老年代的情况。</p>
<p>上述最后当 array3 的大小调整至 128KB 时，发现并不会触发存活对象进入老年代，但是我们可以通过修改 -XX:MaxTenuringThreshold 参数的值为 1，来促进存活对象进入老年代。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];  <span class="comment">// 接着上述的示例代码</span></span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第一次触发 Young GC</span></span><br><span class="line">        array3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 第二次触发 Young GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">1</span>          <span class="comment">// 设置长期存活对象年龄 1 岁，默认 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.4.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.4.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.067: [GC (Allocation Failure) 0.067: [ParNew: 7967K-&gt;462K(9216K), 0.0005621 secs] 7967K-&gt;462K(19456K), 0.0006173 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">0.068: [GC (Allocation Failure) 0.068: [ParNew: 7630K-&gt;0K(9216K), 0.0021220 secs] 7630K-&gt;432K(19456K), 0.0021457 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 432K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代1.png" width="950px"/>

<p>初始分配给 array1 和 array2 的内存空间，其中包括一些辅助的未知对象，当需要给 array3 分配 7MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<img src="模拟长期存活对象直接进入老年代2.png" width="950px"/>

<p>Young GC 之后在 Survivor 区中有 462KB 的存活对象，其中包括 128KB 的 array2 数组对象，和其他 334KB 的未知对象，当需要给 array4 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第二次 Young GC。</p>
<p>之前已经分析过，该示例是不满足动态年龄判断规则的，所以当修改长期存活对象的年龄为 1 岁时，第二次 Young GC 时，之前为 1 岁的存活对象直接进入老年代。</p>
<h3 id="1-2-3-一次-Young-GC-之后存活对象太多无法放入-Survivor-区而进入老年代"><a href="#1-2-3-一次-Young-GC-之后存活对象太多无法放入-Survivor-区而进入老年代" class="headerlink" title="1.2.3 一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代"></a>1.2.3 一次 Young GC 之后存活对象太多无法放入 Survivor 区而进入老年代</h3><p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line">        array2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">10485760</span> <span class="comment">// 大对象阈值 10MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.5.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.5.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.077: [GC (Allocation Failure) 0.077: [ParNew: 6943K-&gt;321K(9216K), 0.0016511 secs] 6943K-&gt;2371K(19456K), 0.0017409 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2451K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,  31% used [0x00000007bf500000, 0x00000007bf550640, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 2050K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<img src="模拟长期存活对象直接进入老年代5.png" width="950px"/>

<p>初始分配给 array1 三次 2MB 和 array2 128KB 大小的内存空间 ，其中包括一些辅助的未知对象，当需要给 array3 分配 2MB 的内存时，发现 Eden 区内存空间是不够的，所以触发第一次 Young GC。</p>
<p>先看下日志：ParNew: 6943K-&gt;321K，这里清晰的说明了，本次 GC 过后，新生代中存活对象为 321KB。此时明明 array1 变量还引用了一个 2MB 的数组，为什么是 321KB 的存活对象呢？</p>
<p>要搞清楚这个问题必须弄清楚以下两个问题：</p>
<ol>
<li>存活下来的 2MB 的数组和 300KB 的未知对象能放入 1MB 的 Survivor From 区吗？答案是不能。</li>
<li>那此时，是不是把这些存活对象全部放入老年代呢？并不是。</li>
</ol>
<p>继续通过日志进行分析。</p>
<p><font color=red>eden space 8192K,  26% used</font>：首先 Eden 区内一定放入了一个新的 2MB 的数组，就是刚才最后想要分配的那个数组，由 array3 变量引用。</p>
<p><font color=red>from space 1024K,  31% used</font>：发现此时 Survivor From 区中有 300KB 多的对象，其实就是那 300KB 多的未知对象！所以在这里并不是让 2MB 的数组和 300KB 多的未知对象都进入老年代，而是把 300KB 的未知对象放入 Survivor From 区中。</p>
<p><font color=red>concurrent mark-sweep generation total 10240K, used 2050K</font>：此时老年代里确有 2MB 的数组，因此可以认为，Young GC 过后，发现存活下来的对象有 2MB 的数组和 300KB 多的未知对象。此时把 300KB 的未知对象放入 Survivor From 区中，然后 2MB 的数组直接放入老年代。</p>
<h3 id="1-2-4-大对象直接进入老年代"><a href="#1-2-4-大对象直接进入老年代" class="headerlink" title="1.2.4 大对象直接进入老年代"></a>1.2.4 大对象直接进入老年代</h3><p>此场景比较容易模拟。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">5242880</span>  <span class="comment">// 大对象阈值 5MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.6.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.6.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 836K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000007bec00000, 0x00000007becd1028, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>通过日志可以很清晰的明白。</p>
<p><font color=red>eden space 8192K,  10% used</font>：未知对象。</p>
<p><font color=red>concurrent mark-sweep generation total 10240K, used 6144K</font>：大对象直接进入老年代。</p>
<h2 id="1-3-Full-GC"><a href="#1-3-Full-GC" class="headerlink" title="1.3 Full GC"></a>1.3 Full GC</h2><p>对于 Young GC、Old GC、Minor GC、Major GC、Full GC 的理解。</p>
<p>三种常见的触发 Full GC 的、时机：</p>
<ol>
<li>年轻代存活的对象太多并且老年代没有足够空间。</li>
<li>触发 Young GC 之前，老年代可用空间小于了历次 Young GC 后升入老年代的对象的平均大小，就会在 Young GC 之前，提前触发 Full GC。</li>
<li>CMS 收集器当老年代被使用率达到了 92% 的阈值触发 Full GC。</li>
</ol>
<p>下面演示下因为年轻代存活的对象太多并且老年代没有足够空间时，触发 Full GC 的场景。</p>
<p>模拟示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] array1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        array1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] array2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] array5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] array6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码执行参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=<span class="number">10485760</span>                <span class="comment">// 新生代大小 10485760B，即 10MB</span></span><br><span class="line">-XX:MaxNewSize=<span class="number">10485760</span>             <span class="comment">// 新生代最大大小 10MB</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">20971520</span>        <span class="comment">// 初始堆大小 20MB</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">20971520</span>            <span class="comment">// 最大堆大小 20MB</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>                 <span class="comment">// 新生代 Eden 与 Survivor 占比为 8:1:1</span></span><br><span class="line">-XX:MaxTenuringThreshold=<span class="number">15</span>         <span class="comment">// 设置长期存活对象年龄 15 岁</span></span><br><span class="line">-XX:PretenureSizeThreshold=<span class="number">3145728</span>  <span class="comment">// 大对象阈值 3MB</span></span><br><span class="line">-XX:+UseParNewGC                    <span class="comment">// 新生代使用 ParNew 垃圾收集器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC             <span class="comment">// 老年代使用 CMS 垃圾收集器</span></span><br><span class="line">-XX:+PrintGCDetails                 <span class="comment">// 打印详细的 GC  日志</span></span><br><span class="line">-XX:+PrintGCTimeStamps              <span class="comment">// 打印出每次 GC 发生的时间</span></span><br><span class="line">-Xloggc:gc.7.log                    <span class="comment">// 设置 GC 日志写入文件路径</span></span><br></pre></td></tr></table></figure>

<p>查看 gc.7.log 日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 省略...</span></span><br><span class="line">0.071: [GC (Allocation Failure) 0.071: [ParNew (promotion failed): 6943K-&gt;7382K(9216K), 0.0024651 secs]0.074: [CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs] 11039K-&gt;6555K(19456K), [Metaspace: 2655K-&gt;2655K(1056768K)], 0.0044161 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 6555K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 2662K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>日志分析：</p>
<img src="FullGC示例分析1.png" width="450px"/>


<p>接下来会分配 array6，那么此时还能放得下 2MB 的对象么？不可能了，因为 Eden 区已经放不下了。因此此时会直接触发一次 Young GC。</p>
<p>ParNew (promotion failed): 6943K-&gt;7382K(9216K)：日志显示原来有 7000KB 左右的对象，Young GC 之后发现一个都回收不掉，因为上述几个数组都被变量引用了。</p>
<p>所以此时，一定会直接把这些对象放入到老年代里去，但是此时老年代里已经有一个 4MB 的数组了，还能放的下 3 个 2MB 的数组和 1 个 128KB 的数组吗？明显是不行的，此时一定会超过老年代的 10MB 大小。所以此时我们看日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs] 11039K-&gt;6555K(19456K), [Metaspace: 2655K-&gt;2655K(1056768K)], 0.0044161 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>

<p>可以清晰看到，此时执行了 CMS 垃圾回收器的 Full GC，Full GC 其实就是会对老年代进行 Old GC，同时一般会跟一次 Young GC 关联，还会触发一次元数据区（永久代）的 GC。在 CMS 的 Full GC 之前，就已经触发过 Young GC 了，此时可以看到 Young GC 就已经执行过了，接着就是执行针对老年代的 Old GC，日志：<font color=red>CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs</font>。</p>
<p>这里看到老年代从 8MB 左右的对象占用，变成了 6MB 左右的对象占用，这是怎么个过程呢？很简单，一定是在 Young GC 之后，先把 2 个 2MB 的数组放入了老年代，如下图。</p>
<img src="FullGC示例分析2.png" width="450px"/>

<p>此时要继续放 1 个 2MB 的数组和 1 个 128KB 的数组到老年代，一定会放不下，所以此时就会触发 CMS 的 Full GC 然后此时就会回收掉那个 4MB 的数组，因为他已经没人引用了，如下图所示。</p>
<img src="FullGC示例分析3.png" width="450px"/>

<p>接着放入进去 1 个 2MB 的数组和 1 个 128KB 的数组，如下图所示。</p>
<div class="note warning">
            <p>疑问：为什么 1 个 128KB 的数组不会进 Survivor 呢？是因为已经发生过 Young GC 了，所以意思是只有在 Young GC 发生的时候才会进入 Survivor 区吗？待验证。</p>
          </div>

<img src="FullGC示例分析4.png" width="450px"/>

<p>所以再看 CMS 的垃圾回收日志：CMS: 8194K-&gt;6555K(10240K), 0.0018743 secs，从回收前的 8MB 变成了 6MB，就是上图所示。</p>
<p>最后在 CMS 的 Full GC 执行完毕之后，其实年轻代的对象都进入了老年代，此时最后一行代码要在年轻代分配 2MB 的数组就可以成功了，如下图。</p>
<img src="FullGC示例分析5.png" width="450px"/>


<h1 id="2-虚拟机性能监控与故障处理工具"><a href="#2-虚拟机性能监控与故障处理工具" class="headerlink" title="2 虚拟机性能监控与故障处理工具"></a>2 虚拟机性能监控与故障处理工具</h1><h2 id="2-1-JDK-命令行工具"><a href="#2-1-JDK-命令行工具" class="headerlink" title="2.1 JDK 命令行工具"></a>2.1 JDK 命令行工具</h2><h3 id="2-1-1-jps：虚拟机进程状况工具（JVM-Process-Status-Tool）"><a href="#2-1-1-jps：虚拟机进程状况工具（JVM-Process-Status-Tool）" class="headerlink" title="2.1.1 jps：虚拟机进程状况工具（JVM Process Status Tool）"></a>2.1.1 jps：虚拟机进程状况工具（JVM Process Status Tool）</h3><p>jps 命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p>jps 可以通过 RMI 协议查询开启 RMI 服务的远程虚拟进程状态，hostid 为 RMI 注册表中注册的主机名。</p>
<p>jps 常用选项：</p>
<ul>
<li>-q：只输出 LVMID（LVMID 与操作系统的进程 PID 是一致的），省略主类名称。</li>
<li>-m：输出虚拟机进程启动时传递给主类 main 方法的参数。</li>
<li>-l：输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径。</li>
<li>-v：输出虚拟机进程启动时的 JVM 参数。</li>
</ul>
<h3 id="2-1-2-jstat：虚拟机统计信息监视工具（JVM-Statistics-Monitoring-Tool）"><a href="#2-1-2-jstat：虚拟机统计信息监视工具（JVM-Statistics-Monitoring-Tool）" class="headerlink" title="2.1.2 jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）"></a>2.1.2 jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）</h3><p>jstat 命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>

<p>jstat 选项：</p>
<ul>
<li>-class：类加载统计</li>
<li>-gc：垃圾回收统计</li>
<li>-gccapacity：堆内存统计</li>
<li>-gcutil：汇总垃圾回收统计</li>
<li>-gccause：与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</li>
<li>-gcnew：新生代垃圾回收统计</li>
<li>-gcnewcapacity：新生代内存统计</li>
<li>-gcold：老年代垃圾回收统计</li>
<li>-gcoldcapacity：年代内存统计</li>
<li>-gcmetacapacity：元空间内存统计</li>
<li>-compiler：编译统计</li>
<li>-printcompilation：编译方法统计</li>
</ul>
<p>虽然有如此多的选项支持，但是最常用、最完整、最实用的还是 jstat -gc 命令，接下来看下该命令的执行结果与展示的信息：</p>
<img src="jstat命令gc日志.png" width="850px"/>


<p>对于此命令下，我们需要关注的几个点：</p>
<ol>
<li>新生代对象增长的速率</li>
<li>Young GC 的触发频率和每次耗时</li>
<li>每次 Young GC 后有多少对象是存活和进入老年代</li>
<li>Full GC 的触发时机和耗时</li>
</ol>
<p>其中新生代对象增长的速率与 Young GC 的触发频率和每次耗时可以通过命令清晰的获取到相关信息。<font color=red>那怎么评估每次 Young GC 后有多少对象是存活和进入老年代呢？</font></p>
<p>其实每次 Young GC 过后有多少对象会存活下来，这个没法直接看出来，但是有办法可以大致推测出来。我们可以很容易推算出来高峰期的时候多久发生一次 Young GC，比如 3 分钟会有一次 Young GC，那么此时我们可以执行下述 jstat 命令：jstat -gc PID 180000 10。这就相当于是让他每隔三分钟执行一次统计，连续执行 10 次。此时大家可以观察一下，每隔三分钟之后发生了一次 Young GC，此时 Eden、Survivor、老年代的对象变化。正常来说，Eden 区肯定会在几乎放满之后重新变得里面对象很少，比如 800MB 的空间就使用了几十 MB。Survivor 区肯定会放入一些存活对象，老年代可能会增长一些对象占用。所以这里的关键，就是观察老年代的对象增长速率。从一个正常的角度来看，老年代的对象是不太可能不停的快速增长的，因为普通的系统其实没那么多长期存活的对象。如果你发现比如每次 Young GC 过后，老年代对象都要增长几十 MB，那很有可能就是你一次 Young GC 过后存活对象太多了。存活对象太多，可能导致放入 Survivor 区域之后触发了动态年龄判定规则进入老年代，也可能是 Survivor 区域放不下了，所以大部分存活对象进入老年代。最常见的就是这种情况。如果你的老年代每次在 Young GC 过后就新增几百 KB，或者几 MB 的对象，这个还算情有可缘，但是如果老年代对象快速增长，那一定是不正常的。所以通过上述观察策略，你就可以知道每次 Young GC 过后多少对象是存活的，实际上 Survivor 区域里的和进入老年代的对象，都是存活的。你也可以知道老年代对象的增长速率，比如每隔 3 分钟一次 Young GC，每次会有 50MB 对象进入老年代，这就是年代对象的增长速率，每隔 3 分钟增长 50MB。</p>
<p><font color=red>关于 Full GC 的触发时机和耗时？</font></p>
<p>只要知道了老年代对象的增长速率，那么 Full GC 的触发时机就很清晰了，比如老年代总共有 800MB 的内存，每隔3分钟新增 50MB 对象，那么大概每小时就会触发一次 Full GC。然后可以看到 jstat 打印出来的系统运行起劲为止的 Full GC 次数以及总耗时，比如一共执行了 10 次 Full GC，共耗时30s，每次 Full GC 大概就是需要耗费 3s 左右。</p>
<h3 id="2-1-3-jmap：Java-内存映像工具（Memory-Map-for-Java）"><a href="#2-1-3-jmap：Java-内存映像工具（Memory-Map-for-Java）" class="headerlink" title="2.1.3 jmap：Java 内存映像工具（Memory Map for Java）"></a>2.1.3 jmap：Java 内存映像工具（Memory Map for Java）</h3><p>其实如果单单只是要了解 JVM 的运行状况，然后去进行 JVM GC 优化，通常来说 jstat 就完全够用了，但是有的时候可能我们会发现 JVM 新增对象的速度很快，然后就想要去看看，到底什么对象占据了那么多的内存。如果发现有的对象在代码中可以优化一下创建的时机，避免那种对象对内存占用过大，那么也许甚至可以去反过来优化一下代码。当然，其实如果不是出现 OOM 那种极端情况，也并没有那么大的必要去着急优化代码。但是这篇文章我们来学习一下如何了解线上系统 JVM 中的对象分布，也是有好处的，比如上述的案例中就发现年轻代里总是有一些未知对象，大家是不是会很好奇？如果可以看到 JVM中这些对象到底是什么就好了，所以学习一下这个技巧是有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary                                 # 显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;      # 打印 Java 对象堆的柱状图，如果指定了“live”子选项，则仅计算活动对象</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics                           # 打印类加载统计信息</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization      # 显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format                   # 生成 Java 堆转储快照</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,   # 是否 dump 出存活的对象</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo       # 当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-jhat：虚拟机堆转储快照分析工具（JVM-Heap-Analysis-Tool）"><a href="#2-1-4-jhat：虚拟机堆转储快照分析工具（JVM-Heap-Analysis-Tool）" class="headerlink" title="2.1.4 jhat：虚拟机堆转储快照分析工具（JVM Heap Analysis Tool）"></a>2.1.4 jhat：虚拟机堆转储快照分析工具（JVM Heap Analysis Tool）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being &quot;new&quot;.</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br><span class="line">All boolean options default to &quot;true&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># jhat dump.bin </span><br><span class="line">Reading from dump.bin...</span><br><span class="line">Dump file created Sun Nov 24 10:42:54 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 1321689 objects...</span><br><span class="line">Chasing references, expect 264 dots........................................................................................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references........................................................................................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<img src="jhat图1.png" width="850px"/>


<h3 id="2-1-5-jstack：Java-堆栈跟踪工具（Strack-Trace-for-Java）"><a href="#2-1-5-jstack：Java-堆栈跟踪工具（Strack-Trace-for-Java）" class="headerlink" title="2.1.5 jstack：Java 堆栈跟踪工具（Strack Trace for Java）"></a>2.1.5 jstack：Java 堆栈跟踪工具（Strack Trace for Java）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) # 当正常输出的请求不被响应时，强制输出线程堆栈</span><br><span class="line">    -m  to print both java and native frames (mixed mode)                                # 除堆栈</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure>




<h2 id="2-2-JDK-可视化工具"><a href="#2-2-JDK-可视化工具" class="headerlink" title="2.2 JDK 可视化工具"></a>2.2 JDK 可视化工具</h2><h3 id="2-2-1-jconsole：Java-监视与管理控制台"><a href="#2-2-1-jconsole：Java-监视与管理控制台" class="headerlink" title="2.2.1 jconsole：Java 监视与管理控制台"></a>2.2.1 jconsole：Java 监视与管理控制台</h3><h3 id="2-2-2-visualvm：多合一故障处理工具"><a href="#2-2-2-visualvm：多合一故障处理工具" class="headerlink" title="2.2.2 visualvm：多合一故障处理工具"></a>2.2.2 visualvm：多合一故障处理工具</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/26/JVM-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM-04-虚拟机类加载机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 16:58:03" itemprop="dateCreated datePublished" datetime="2019-11-26T16:58:03+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1 类的加载过程"></a>1 类的加载过程</h1><h2 id="1-1-类的生命周期"><a href="#1-1-类的生命周期" class="headerlink" title="1.1 类的生命周期"></a>1.1 类的生命周期</h2><!-- ![](类的生命周期.png) -->

<img src="./类的生命周期.png" width="800px"/>

<p>这些阶段通常都是相互交叉地混合式进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p>
<p>在如下几种情况下，Java 虚拟机将结束生命周期：</p>
<ul>
<li>执行了 System.exit() 方法（实质为给虚拟机本身发送一个执行使其终止）。</li>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于<font color="red">操作系统出现错误</font>而导致 Java 虚拟机进程终止。</li>
</ul>
<h2 id="1-2-主动引用"><a href="#1-2-主动引用" class="headerlink" title="1.2 主动引用"></a>1.2 主动引用</h2><p>虚拟机规范严格规定有且只有 5 种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始），称为主动引用：</p>
<ol>
<li>遇到 new、getstatic、putstatic、invokestatic 字节码指令，生成这 4 条指令的最常见场景：① 使用 new 实例化对象；② 读取或设置一个类的 static 字段（被 final 修饰，已在编译器把结果放入常量池的静态字段除外）；③ 调用类的静态方法。</li>
<li>使用 java.lang.reflect 包的方法对类进行<font color="red">反射</font>调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类时，如果其父类还没初始化，需先初始化父类。<font color="red">这点类与接口具有不同的表现</font>，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。<font color="red">注意：接口的实现类在初始化时也一样不会要求接口完成初始化</font>。</li>
<li>当虚拟机启动时，用户需要指定一个执行的主类，即包含 main 方法的那个类，虚拟机会先初始化这个主类。</li>
<li>JDK 1.7 动态语言支持：如果一个 java.lang.invoke.MethodHandle 的实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<h2 id="1-3-被动引用"><a href="#1-3-被动引用" class="headerlink" title="1.3 被动引用"></a>1.3 被动引用</h2><p>除此之外都不会触发初始化，称为被动引用，主要列举以下 3 种情况：</p>
<ol>
<li>通过子类引用父类静态字段，只会导致父类的初始化而不会导致子类初始化。HotSpot 可通过 -XX:+TraceClassLoading 参数导致子类的加载。</li>
<li>Array[] arr = new Array[10]; 不会触发 Array 类初始化。</li>
<li>static final VAR 在编译阶段会存入调用类的常量池，通过 ClassName.VAR 引用不会触发 ClassName 初始化。注意：<font color=red>当一个常量的值并非编译期间可以确定，那么其值就不会放入调用类的常量池中，因此当使用该常量值，就会导致该常量所在类的初始化</font>。</li>
<li><font color="red">调用 ClassLoader 的 loadClass 方法不会导致类的初始化</font>。</li>
</ol>
<h2 id="1-4-类的加载"><a href="#1-4-类的加载" class="headerlink" title="1.4 类的加载"></a>1.4 类的加载</h2><p>类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个 java.lang.Class 对象用来封装类在方法区内的数据结构。<font color="red">JVM 规范中并未说明 Class 对象位于哪里，Hotspot 虚拟机将其放在方法区中</font>。</p>
<p>JVM 规范允许类加载器在预料某个类将要被使用时就<font color="red">预先加载</font>它，如果在预先加载的过程中遇到了 .class 文件缺失或存在错误，类加载器会在程序首次主动引用该类时报告 <font color="red">LinkageError</font> 错误。如果这个类一直没有被程序主动引用，那么<font color="red">类加载器就不会报告错误</font>。</p>
<blockquote>
<p>通过添加：-XX:+TraceClassLoading 程序运行时将打印类的加载过程。</p>
</blockquote>
<p>类加载的 .class 文件的来源：</p>
<ol>
<li>从 ZIP 包中读取；</li>
<li>从网络中获取；</li>
<li>运行时计算生成，比如动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 类来为特定接口生成形式为 $Proxy 的代理类的二进制字节流；</li>
<li>有其他文件生成，比如 JSP；</li>
<li>从数据库中读取。</li>
</ol>
<h2 id="1-5-连接-验证"><a href="#1-5-连接-验证" class="headerlink" title="1.5 连接-验证"></a>1.5 连接-验证</h2><p>目的： 确保 class 文件中的字节流信息符合虚拟机的要求。</p>
<p>4 个验证过程：</p>
<ol>
<li>文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” 0xCAFEBABE；</li>
<li>元数据验证：保证字节码描述信息符号 Java 规范（语义分析）；</li>
<li>字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）；</li>
<li>符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验。</li>
</ol>
<blockquote>
<p>这个操作虽然重要，但不是必要的，可以通过 -Xverify:none 关掉。</p>
</blockquote>
<h2 id="1-6-连接-准备"><a href="#1-6-连接-准备" class="headerlink" title="1.6 连接-准备"></a>1.6 连接-准备</h2><p>描述： 为静态变量在方法区分配内存，并设置默认的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备后为 0，value 的赋值指令 putstatic 会被放在 &lt;client&gt;() 方法中，&lt;client&gt;() 方法</span></span><br><span class="line"><span class="comment">// 会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 准备后为 123，因为被 static final 赋值之后 value 就不能再修改了，所以在这里进行了赋值</span></span><br><span class="line"><span class="comment">// 之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


<h2 id="1-7-连接-解析"><a href="#1-7-连接-解析" class="headerlink" title="1.7 连接-解析"></a>1.7 连接-解析</h2><p>描述： 将常量池中的符号引用替换为直接引用。在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。</p>
<p>符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。</p>
<p>直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。</p>
<h2 id="1-8-初始化"><a href="#1-8-初始化" class="headerlink" title="1.8 初始化"></a>1.8 初始化</h2><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，<font color=red>初始化阶段是执行类构造器 &lt;client&gt;() 方法的过程</font>。</p>
<ol>
<li>&lt;client&gt;() 方法是由编译器自动收集类中的所有<font color=red>类变量的赋值动作</font>和<font color=red>静态语句块</font>（static {} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</li>
<li>&lt;client&gt;() 方法与类的构造函数（或者说实例构造器 <font color=blue>init&lt;&gt;()</font> 方法）不同，它<font color=red>不需要显示地调用父类构造器，虚拟机会保证在子类的 &lt;client&gt;() 方法执行之前，父类的 &lt;client&gt;() 方法已经执行完毕</font>。因此在虚拟机中第一个被执行的 &lt;client&gt;() 方法的类肯定是 java.lang.Object。</li>
<li>由于父类的 &lt;client&gt;() 方法先执行，也就意味着<font color=red>父类中定义的类变量的赋值和静态语句块要先于子类</font>。</li>
<li>&lt;client&gt;() 方法对于类或者接口<font color=red>并不是必须的</font>。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 &lt;client&gt;() 方法。<font color=red>但接口与类不同的是</font>，执行接口的 &lt;client&gt;() 方法不需要先执行父接口的 &lt;client&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，<font color=red>接口的实现类在初始化时也一样不会执行接口的 &lt;client&gt;() 方法</font>。</li>
<li>虚拟机会保证一个类的 &lt;client&gt;() 方法在多线程执行环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 &lt;client&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行 &lt;client&gt;() 方法完毕。如果在一个类的 &lt;client&gt;() 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。需要注意的是，其他线程虽然会被阻塞，但如果执行 &lt;client&gt;() 方法的那条线程退出 &lt;client&gt;() 方法后，其他线程唤醒之后不会再次进入 &lt;client&gt;() 方法。<font color=red>同一个类加载器下，一个类型只会初始化一次</font>。 </li>
</ol>
<h2 id="1-9-实战"><a href="#1-9-实战" class="headerlink" title="1.9 实战"></a>1.9 实战</h2><h3 id="1-9-1-子类与父类中静态字段的加载与初始化"><a href="#1-9-1-子类与父类中静态字段的加载与初始化" class="headerlink" title="1.9.1 子类与父类中静态字段的加载与初始化"></a>1.9.1 子类与父类中静态字段的加载与初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p>当在 Child 类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"welcome"</span>; <span class="comment">// 添加代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// Child static block</span></span><br><span class="line"><span class="comment">// welcome</span></span><br></pre></td></tr></table></figure>

<p>结论 1：初始化一个类时，其父类还没初始化，需先初始化父类。<br>结论 2：通过子类引用父类静态字段，只会导致父类的初始化而不会导致子类初始化。</p>
<p>通过添加：-XX:+TraceClassLoading 观察上述两种情况下类的加载过程。</p>
<div class="note success">
            <p>-XX:+option，表示开启 option 选项，默认没有开启需要开启的情况。<br>-XX:-option，表示关闭 option 选项，默认已经开启需要关闭的情况。<br>-XX:option=value，表示将 option 选项的值设置为 value。</p>
          </div>


<p>根据 《深入理解Java虚拟机：JVM高级特性与最佳实践》 得知，其<font color="red">子类的加载是因为使用 -XX:+TraceClassLoading 参数</font>。</p>
<h3 id="1-9-2-编译期常量所在类的初始化"><a href="#1-9-2-编译期常量所在类的初始化" class="headerlink" title="1.9.2 编译期常量所在类的初始化"></a>1.9.2 编译期常量所在类的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：hello world，因为 static final 类型的变量在编译期已经存入 MyTest 类的常量池中。所以，通过 Parent.str 引用不会触发 Parent 初始化。将上述代码反编译结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MyTest.class</span></span><br><span class="line">Compiled from "MyTest.java"</span><br><span class="line">public class com.westboy.MyTest &#123;</span><br><span class="line">  public com.westboy.MyTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #4                  // String hello world</span><br><span class="line">       5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中扩展几个常用的助记符：</p>
<div class="note success">
            <p>ldc：表示将 int，float 或是 String 类型的常量值从常量池中推送至栈顶。<br>bipush：表示将单字节（-128 ~ 127）的常量值推送至栈顶。<br>sipush：表示将一个短整型常量值（-32768 ~ 32767）常量值推送至栈顶。<br>iconst_1：表示将 int 类型 1 推送至栈顶（iconst_m1，iconst_0 ~ iconst_5，HotSpot JVM 可能认为 int 类型 -1 ~ 5 是比较常用的类型，所以单另使用一种助记符）。</p>
          </div>

<p>关于上述的 iconst 的范围可参考：com.sun.org.apache.bcel.internal.generic.ICONST 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ICONST</span> <span class="keyword">extends</span> <span class="title">Instruction</span> <span class="keyword">implements</span> <span class="title">ConstantPushInstruction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ICONST</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((<span class="keyword">short</span>)<span class="number">3</span>, (<span class="keyword">short</span>)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= -<span class="number">1</span> &amp;&amp; i &lt;= <span class="number">5</span>) &#123; <span class="comment">// 就是上述的范围（iconst_m1，iconst_0 ~ iconst_5）</span></span><br><span class="line">            <span class="keyword">super</span>.setOpcode((<span class="keyword">short</span>)(<span class="number">3</span> + i));</span><br><span class="line">            <span class="keyword">this</span>.value = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassGenException(<span class="string">"ICONST can be used only for value between -1 and 5: "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也会发现对于助记符 sipush 也有对应的类实现（com.sun.org.apache.bcel.internal.generic.SIPUSH），所以对于这些助记符底层都是通过相应的类进行实现的。</p>
<h3 id="1-9-3-非编译期常量所在类的初始化"><a href="#1-9-3-非编译期常量所在类的初始化" class="headerlink" title="1.9.3 非编译期常量所在类的初始化"></a>1.9.3 非编译期常量所在类的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Parent.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// Parent static block</span></span><br><span class="line"><span class="comment">// 4475c0db-fa99-4c86-9d81-506bde28ec73</span></span><br></pre></td></tr></table></figure>

<p>结论：<font color=red>当一个常量的值并非编译期间可以确定，那么其值就不会放入调用类的常量池中</font>，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类初始化。</p>
<h3 id="1-9-4-数组实例的类型创建时机"><a href="#1-9-4-数组实例的类型创建时机" class="headerlink" title="1.9.4 数组实例的类型创建时机"></a>1.9.4 数组实例的类型创建时机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parent[] parents1 = <span class="keyword">new</span> Parent[<span class="number">1</span>];</span><br><span class="line">        System.out.println(parents1.getClass());</span><br><span class="line">        System.out.println(parents1.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        Parent[][] parents2 = <span class="keyword">new</span> Parent[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        System.out.println(parents2.getClass());</span><br><span class="line">        System.out.println(parents2.getClass().getSuperclass());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：并没有对 Parent 类进行初始化操作</span></span><br><span class="line"><span class="comment">// class [Lcom.westboy.Parent;</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [[Lcom.westboy.Parent;</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [I</span></span><br><span class="line"><span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// class [C</span></span><br></pre></td></tr></table></figure>

<p>结论：对于数组实例来说，其类型是由 JVM 在运行期动态生成的，表示为：[Lcom.westboy.Parent 这种形式。动态生成的类型，其父类型就是 Object。对于数组来说，JavaDoc 经常将构建成数组的元素称之为 Component，实际上就是将数组降低一个维度后的类型。</p>
<p>反编译执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MyTest.class</span></span><br><span class="line">Compiled from "MyTest.java"</span><br><span class="line">public class com.westboy.MyTest &#123;</span><br><span class="line">  public com.westboy.MyTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1</span><br><span class="line">       1: anewarray     #2                  // class com/westboy/Parent</span><br><span class="line">       4: astore_1</span><br><span class="line">       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      12: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      15: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      22: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      25: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      28: iconst_1</span><br><span class="line">      29: iconst_1</span><br><span class="line">      30: multianewarray #7,  2             // class "[[Lcom/westboy/Parent;"</span><br><span class="line">      34: astore_2</span><br><span class="line">      35: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      38: aload_2</span><br><span class="line">      39: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      42: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      45: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      48: aload_2</span><br><span class="line">      49: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      52: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      55: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      58: iconst_1</span><br><span class="line">      59: newarray       int</span><br><span class="line">      61: astore_3</span><br><span class="line">      62: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      65: aload_3</span><br><span class="line">      66: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      69: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      72: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      75: aload_3</span><br><span class="line">      76: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      79: invokevirtual #6                  // Method java/lang/Class.getSuperclass:()Ljava/lang/Class;</span><br><span class="line">      82: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">      85: iconst_1</span><br><span class="line">      86: newarray       char</span><br><span class="line">      88: astore        4</span><br><span class="line">      90: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      93: aload         4</span><br><span class="line">      95: invokevirtual #4                  // Method java/lang/Object.getClass:()Ljava/lang/Class;</span><br><span class="line">      98: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">     101: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展助记符：</p>
<div class="note success">
            <p>anewarray：表示创建一个一维引用类型（如类，接口和数组）的数组，并将其引用值压入栈顶。<br>newarray：表示创建一个指定的原始类型（如 int，float，char 等）的数组，并将其引用值压入栈顶。<br>multianewarray：表示创建一个多维引用类型（如类，接口和数组）的数组，并将其引用值压入栈顶。</p>
          </div>

<p>ClassLoader API Doc 中的片段：<font color="red">数组类型的 Class 对象并不是由类加载器创建的，它是在 Java 运行期自动创建的，通过数组获取的类加载器是与其数组中元素类型通过 Class.getClassLoader 方法获取的类加载器是一致的，如果元素类型是原生类型，那么数组类是没有类加载器的</font>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">System.out.println(String.class.getClassLoader());</span><br><span class="line">System.out.println(strings.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// null # String 类型由启动类加载器加载，所有返回为 null</span></span><br><span class="line"><span class="comment">// null # 通过数组获取的类加载器是与其数组中元素类型通过 Class.getClassLoader 方法获取的类加载器是一致的</span></span><br><span class="line"></span><br><span class="line">MyTest15[] myTest15s = <span class="keyword">new</span> MyTest15[<span class="number">2</span>];</span><br><span class="line">System.out.println(MyTest15.class.getClassLoader());</span><br><span class="line">System.out.println(myTest15s.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2 # MyTest15 由应用类加载器加载</span></span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(<span class="keyword">int</span>.class.getClassLoader());</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// null # 注意此处的 null 与 上述的 null 不一样，数组类是没有类加载器的</span></span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="1-9-5-接口相关的初始化"><a href="#1-9-5-接口相关的初始化" class="headerlink" title="1.9.5 接口相关的初始化"></a>1.9.5 接口相关的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild</span> <span class="keyword">implements</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>结论 1：接口的实现类在初始化时不会要求接口的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyChild</span> <span class="keyword">extends</span> <span class="title">MyParent</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// MyChild invoked</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure>

<p>结论 2：接口初始化时，不要求其父接口完成初始化。</p>
<h3 id="1-9-6-初始化阶段分析"><a href="#1-9-6-初始化阶段分析" class="headerlink" title="1.9.6 初始化阶段分析"></a>1.9.6 初始化阶段分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"counter1: "</span> + Singleton.counter1);</span><br><span class="line">        System.out.println(<span class="string">"counter2: "</span> + Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>; <span class="comment">// 标注 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// counter1: 1</span></span><br><span class="line"><span class="comment">// counter2: 1</span></span><br></pre></td></tr></table></figure>

<p>变更下标注 1 行代码的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// counter1: 1</span></span><br><span class="line"><span class="comment">// counter2: 0</span></span><br></pre></td></tr></table></figure>

<p><font color=red>为什么只是变更了一下位置结果却不一样呢？</font></p>
<p>首先按照加载-连接-初始化的流程，在连接的准备阶段按照从上到下的顺序会对 counter1 和 counter2 和 singleton 三个静态变量分配内存，并初始化默认值，即连接阶段的结果为：counter1 = 0，counter2 = 0 和 singleton = null，又因为 main 方法调用 Singleton.getInstance() 时为上述主动引用中的第一种情况中的第 ③ 种情况：使用静态方法，会使得 Singleton 进行初始化，初始化阶段为对静态变量赋予正确的初始值（见下），但是 counter1 与 counter2 没有进行赋值操作取默认值，所以依然没变，接下来对 singleton 进行初始化操作，在使用 Singleton 构造方法生成对象时，又对 counter1 和 counter2 进行了自增运算，并重新赋值，所以在初始化阶段结束之后：counter1 = 1，counter2 = 1。</p>
<p>与第一种情况不同的是 counter2 与 singleton 两个变量交换了位置，按照加载-连接-初始化的流程，连接阶段的结果依然为：counter1 = 0，counter2 = 0 和 singleton = null，但是在初始化阶段，不同于第一种情况，先对 singleton 进行初始化，其初始化完成后 counter1 = 0，counter2 = 0，接下来继续对 counter2 进行初始化，由于没有对 counter2 进行赋值操作取默认值，导致最终结果为：counter1 = 1，counter2 = 0。</p>
<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3 类加载器"></a>3 类加载器</h1><h2 id="3-1-类与类加载器"><a href="#3-1-类与类加载器" class="headerlink" title="3.1 类与类加载器"></a>3.1 类与类加载器</h2><p><font color="red">Bootsrap ClassLoader：启动类加载器（也称根类加载器）</font>：该类加载器负责加载 JAVA_HOME/jre/lib 或者由 -Xbootclasspath 参数（或者使用 -D 选项指定 sun.boot.class.path ）所指定的路径中的，并且是虚拟机识别的类库到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取启动类加载器所加载的全部 URL 数组</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">            System.out.println(urls[i].toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">// file:/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/classes</span></span><br></pre></td></tr></table></figure>



<p><font color="red">Extension ClassLoader：扩展类加载器</font>：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现。它负责加载 JAVA_HOME/jre/lib/ext 或者由 java.ext.dirs 系统指定的目录中的 JAR 包的类。</p>
<p>通过这种方式，就可以为 Java 扩展核心类以外的新功能，只要把自己开发的类打成 JAR 文件，然后放入 JAVA_HOME/jre/lib/ext 路径即可。</p>
<p><font color="red">System ClassLoader：系统类加载器（也称应用类加载器）</font>：这个加载器由 sun.misc.Launcher$AppClassLoader 实现。它负责在 JVM 启动时加载来自 java 命令的 -classpath 选项、java.class.path 系统属性，或 CLASSPATH 环境变量所指定的 JAR 包和类路径。程序可以用通过 ClassLoader 的静态方法 getSystemClassLoader() 方法来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以应用类加载器作为父加载器。</p>
<p><font color="blue">扩展-1</font>：可以通过以下方法获取到每个类加载器默认所加载的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest18</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"sun.boot.class.path"</span>, <span class="string">"启动类加载器"</span>);</span><br><span class="line">        print(<span class="string">"java.ext.dirs"</span>, <span class="string">"扩展类加载器"</span>);</span><br><span class="line">        print(<span class="string">"java.class.path"</span>, <span class="string">"应用类加载器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        System.out.println(classLoaderName + <span class="string">"加载路径: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : System.getProperty(s).split(<span class="string">":"</span>)) &#123;</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ➜  classes git:(master) ✗ java com.westboy.MyTest18 使用 java 命令执行，如果在 IDEA 下执行结果不一样</span></span><br><span class="line"><span class="comment">// 启动类加载器加载路径: </span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/resources.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/rt.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/sunrsasign.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jsse.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jce.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/charsets.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/jfr.jar</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/classes</span></span><br><span class="line"><span class="comment">// 扩展类加载器加载路径: </span></span><br><span class="line"><span class="comment">// /Users/westboy/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home/jre/lib/ext</span></span><br><span class="line"><span class="comment">// /Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /Network/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /System/Library/Java/Extensions</span></span><br><span class="line"><span class="comment">// /usr/lib/java</span></span><br><span class="line"><span class="comment">// 应用类加载器加载路径: </span></span><br><span class="line"><span class="comment">// .   &lt;-------------- 注意 . 代表当前的路径</span></span><br></pre></td></tr></table></figure>

<!-- ![](JVM自带类加载器加载路径.png) -->

<!-- <img src="./JVM自带类加载器加载路径.png" width="650px"/> -->

<p><font color="blue">扩展-2</font>：扩展类加载器注意要点：扩展类加载器需要将加载的类打成 jar 放置在加载目录下才能加载，而启动类加载器与应用类加载器只需要将 .class 文件放置在加载目录下即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest22</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyTest22 initializer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyTest22.class.getClassLoader());</span><br><span class="line">        System.out.println(MyTest15.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不打包执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ pwd                                         </span><br><span class="line">/Users/westboy/IdeaProjects/personal/java-learning/shengsiyuan-jvm/target/classes # 当前路径</span><br><span class="line">➜  classes git:(master) ✗ java -Djava.ext.dirs=./ com.westboy.MyTest22</span><br><span class="line">MyTest22 initializer</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest22 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest15 由应用类加载器加载</span><br></pre></td></tr></table></figure>

<p>打包执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ jar cvf test.jar com/westboy/MyTest15.class             # 打包操作 </span><br><span class="line">已添加清单</span><br><span class="line">正在添加: com/westboy/MyTest15.class(输入 = 1121) (输出 = 589)(压缩了 47%)</span><br><span class="line">➜  classes git:(master) ✗ java -Djava.ext.dirs=./ com.westboy.MyTest22            # 打包结束后执行</span><br><span class="line">MyTest22 initializer</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55                                         # MyTest22 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@33909752                                         # MyTest15 由扩展类加载器加载</span><br></pre></td></tr></table></figure>

<p>结论：<font color="red">可见扩展类加载器需要将加载的类打成 jar 放置在加载目录下才能加载，而启动类加载器与应用类加载器只需要将 .class 文件放置在加载目录下即可</font>。</p>
<p><font color="blue">扩展-3</font>：修改默认的应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证 ClassLoader 类的类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader()); </span><br><span class="line">        <span class="comment">// 间接验证扩展类加载器与应用类加载器的类加载器</span></span><br><span class="line">        System.out.println(Launcher.class.getClassLoader()); </span><br><span class="line">        <span class="comment">// 默认的情况下，java.system.class.loader 属性没有被定义，打印结果为 null，所以应用类加载器默认指向 Launcher$AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>)); </span><br><span class="line">        System.out.println(MyTest23.class.getClassLoader());</span><br><span class="line">        System.out.println(MyTest16.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  classes git:(master) ✗ java -Djava.system.class.loader=com.westboy.MyTest16 com.westboy.MyTest23 # 修改 java.system.class.loader 属性</span><br><span class="line">null                                        # ClassLoader 是由启动类加载器加载</span><br><span class="line">null                                        # 扩展类加载器与应用类加载器也是由启动类加载器所加载的</span><br><span class="line">com.westboy.MyTest16                        # 默认的类加载器已经被修改</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2   # MyTest23 由应用类加载器加载</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2   # MyTest16 由应用类加载器加载</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;null&apos;&#125;            # 可见将 java.system.class.loader 属性设置为 MyTest16 类加载器已经生效</span><br></pre></td></tr></table></figure>

<p>注意：在引用之前 MyTest16 的类加载器的时候，必须添加如下构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因参见：<font color="red">待补充…</font></p>
<!-- ![](获取应用类加载器方法注释.png) -->

<!-- 启动类加载器并不是 Java 类，而其他的加载器是 Java 类，启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。
所有类加载器（除启动类加载器）都被实现为 Java 类。不过，总归要有一个组件来加载第一个 Java 类加载器，从而让整个加载过程能够顺利进行下去，<font color="red">加载第一个纯 Java 类加载器就是启动类加载器的职责</font>。
启动类加载还会负责加载 JRE 正常所需要的基本组件，这包括 java.util 与 java.lang 包中的类等等。 -->

<h2 id="3-2-类的加载机制"><a href="#3-2-类的加载机制" class="headerlink" title="3.2 类的加载机制"></a>3.2 类的加载机制</h2><p>JVM 的类加载机制主要有如下三种。</p>
<p><font color="red">① 全盘负责</font>。所谓全盘负责，就是当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另一个类加载器来加载。<br><font color="red">② 双亲委派（父类委托）</font>。所谓父类委托，则是先让父类加载器视图加载该 Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。<br><font color="red">③ 缓存机制</font>。缓存机制将会保存所有加载过的 Class 都会被缓存，当程序中需要用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区中，这就是为什么修改了 Class 后，必须重启 JVM，程序所做的修改才会生效的原因。</p>
<h2 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h2><!-- ![](双亲委派模型.png) -->

<img src="./双亲委派模型.png" width="650px"/>

<p>上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系<font color="red">一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）</font>。</p>
<div class="note warning">
            <p>类加载器的父子关系不是通过继承来实现的，比如 AppClassLoader 并不是 ExtClassLoader 的子类，而是说 AppClassLoader 的 parent 成员变量指向 ExtClassLoader 对象。</p>
          </div>


<p><font color="red">双亲委派模型的工作过程</font>：</p>
<p>① 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。<br>② 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。<br>③ 只有当父类加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p><font color="red">双亲委派模型的优点</font>：</p>
<p>① <font color="#0066FF">可以确保 Java 核心库的类型安全</font>：例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。而且这些之间还是不兼容的，相互不可见的（正是命名空间在发挥作用，类加载器的命名空间在下文<a href="#3-5-自定义-ClassLoader">自定义 ClassLoader </a>中会顺带讲解）。<br>② <font color="#0066FF">可以确保 Java 核心类库所提供的类不会被自定义的类所替代</font>。<br>③ <font color="#0066FF">不同类加载器可以为相同名称的类创建额外的命名空间</font>。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个又一个相互隔离的 Java 类空间，这类技术在很多框架中都得到了实际应用。</p>
<div class="note warning">
            <p>TODO 类加载器的命名空间</p>
          </div>


<p><font color="red">双亲委派模型的系统实现</font>：</p>
<p>双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却很简单，实现集中在 java.lang.ClassLoader 的 loadClass 方法中，在其方法中，<font color="red">主要判断逻辑</font>：先检查是否已经被加载过，若没有加载则调用父类加载器的 loadClass 方法，若父类加载器为空默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass 方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-3-破坏双亲委派模型（TODO-简化）"><a href="#3-3-破坏双亲委派模型（TODO-简化）" class="headerlink" title="3.3 破坏双亲委派模型（TODO 简化）"></a>3.3 破坏双亲委派模型（TODO 简化）</h2><p>双亲委派模型<font color="red">并不是一个强制性的约束模型</font>。而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外。</p>
<p>双亲委派模型的<font color="red">第一次“被破坏”</font>其实发生在双亲委派模型出现之前—即 JDK1.2 发布之前。由于双亲委派模型是在 JDK1.2 之后才被引入的，而类加载器和抽象类 java.lang.ClassLoader 则是 JDK1.0 时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2 之后的 java.lang.ClassLoader 添加了一个新的 proceted 方法 findClass，在此之前，用户去继承 java.lang.ClassLoader 的唯一目的就是重写 loadClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal，而这个方法的唯一逻辑就是去调用自己的 loadClass。JDK1.2 之后已不再提倡用户再去覆盖 loadClass 方法，应当把自己的类加载逻辑写到 findClass 方法中，在 loadClass 方法的逻辑里，如果父类加载器加载失败，则会调用自己的 findClass 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。</p>
<p>双亲委派模型的<font color="red">第二次“被破坏”</font>是这个模型自身的缺陷所导致的，双亲委派模型很好地解决了各个类加载器的基础类统一问题（越基础的类由越上层的加载器进行加载），基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的 API。但是，如果基础类又要调用用户的代码，那该怎么办呢？</p>
<p>这并非是不可能的事情，一个典型的例子便是 JNDI 服务，它的代码由启动类加载器去加载（在 JDK1.3 时放进 rt.jar），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的 classpath 下的 JNDI 接口提供者（SPI, Service Provider Interface）的代码，但启动类加载器不可能“认识”之些代码，该怎么办？</p>
<p>为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：<font color="red">线程上下文件类加载器</font>（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI，JDBC，JCE，JAXB 和 JBI 等。</p>
<blockquote>
<p>关于线程上下文件类加载器扩展知识参见：<a href="#3-5-线程上下文类加载器分析">3.5 线程上下文类加载器分析</a></p>
</blockquote>
<div class="note danger">
            <p><strong>双亲委派模型破坏举例</strong>（淘宝面试题）</p><p>原生的 JDBC 中 Driver 驱动本身只是一个接口，并没有具体的实现，具体的实现是由不同数据库类型去实现的。例如，MySQL 的 mysql-connector-java.jar 中的 Driver 类具体实现的。 原生的 JDBC 中的类是放在 rt.jar 包的，是由启动类加载器进行类加载的，在 JDBC 中的 Driver 类中需要动态去加载不同数据库类型的 Driver 类，而 mysql-connector-java.jar 中的 Driver 类是用户自己写的代码，那<font color="red">启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载。于是乎，这个时候就引入线程上下文件类加载器。因此，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了</font>。代码分析参见：<a href="#3-4-破坏双亲委派模型的-JDBC-实现案例">3.4 破坏双亲委派模型的-JDBC-实现案例</a></p>
          </div>

<p>双亲委派模型的<font color="red">第三次“被破坏”</font>是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。</p>
<p>OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 坏境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>
<ol>
<li>将 java.＊ 开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载。</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</li>
<li>否则，类加载器失败。</li>
</ol>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>
<p>虽然使用了“被破坏”这个词形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可以认为是一种创新。</p>
<h2 id="3-4-破坏双亲委派模型的-JDBC-实现案例"><a href="#3-4-破坏双亲委派模型的-JDBC-实现案例" class="headerlink" title="3.4 破坏双亲委派模型的 JDBC 实现案例"></a>3.4 破坏双亲委派模型的 JDBC 实现案例</h2><p>我们结合 Driver 来看一下在 SPI（Service Provider Inteface）中如何实现破坏双亲委派。</p>
<p>先从 DriverManager 开始看，平时我们通过 DriverManager 来获取数据库的 Connection：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/testdb"</span>;</span><br><span class="line">Connection conn = java.sql.DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure>

<p>在调用 DriverManager 的时候，会先初始化类，调用其中的静态块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加载Driver的实现类</span></span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了节约空间，笔者省略了一部分的代码，重点来看一下 ServiceLoader.load(Driver.class)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程中的上下文类加载器</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，load 方法调用获取了当前线程中的上下文类加载器，那么上下文类加载器放的是什么加载器呢？在 sun.misc.Launcher 中，我们找到了答案，在 Launcher 初始化的时候，会获取 AppClassLoader，然后将其设置为上下文类加载器，而这个 AppClassLoader，就是之前上文提到的应用类加载器，所以<font color="red">线程上下文类加载器默认情况下就是应用类加载器</font>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Launcher &#123;</span><br><span class="line">    public Launcher() &#123;</span><br><span class="line">        ...</span><br><span class="line">        try &#123;</span><br><span class="line">            this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续来看下 ServiceLoader.load(service, cl)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    <span class="comment">// ClassLoader.getSystemClassLoader() 获取应用类加载器</span></span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段就不解释了，比较简单，然后就是看 LazyIterator 迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// ServiceLoader 的 iterator() 方法最后调用的是这个迭代器里的 next</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 根据名字来加载类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            S p = service.cast(c.newInstance());</span><br><span class="line">            providers.put(cn, p);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> hasNextService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 在 classpath 下查找 META-INF/services/java.sql.Driver 名字的文件夹</span></span><br><span class="line">                <span class="comment">// private static final String PREFIX = "META-INF/services/";</span></span><br><span class="line">                String fullName = PREFIX + service.getName();</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                    configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    configs = loader.getResources(fullName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这里基本就差不多完成整个流程了，一起走一遍：</p>
<p><img src="JDBC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p>
<h2 id="3-5-线程上下文类加载器分析"><a href="#3-5-线程上下文类加载器分析" class="headerlink" title="3.5 线程上下文类加载器分析"></a>3.5 线程上下文类加载器分析</h2><p>线程上下文类加载器（Context ClassLoader）：线程上下文类加载器是从 JDK1.2 开始引入的，类 Thread 中 getContextClassLoader 与 setContextClassLoader 方法分别用来获取和设置上下文类加载器。</p>
<p><font color="blue">扩展-1</font>：线程上下文类加载器默认使用应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器</span><br><span class="line">null                                      # 启动类加载器</span><br></pre></td></tr></table></figure>

<p>这里首先要理解类加载中的一个机制，如果一个类由类加载器 A 加载，那么这个类的依赖类也是由相同的类加载器 A 加载的（如果该依赖之前没有被加载过的话），什么是指依赖类呢？依赖类是指当前类使用的其它类，将其它类称之为当前类的依赖类。上下文类加载器的作用就是为了破坏 Java 的类加载委托机制。它是怎么实现的呢？其实在<a href="3-4-破坏双亲委派模型的-JDBC-实现案例">3.4 破坏双亲委派模型的 JDBC 实现案例</a>中的代码分析已经有说明，是通过在 Launcher  类的构造方法中设置的。所以上述上下文类加载器的打印结果即应用类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><font color="blue">扩展-2</font>：线程上下文类加载器的一般使用模式。当高层提供了统一的接口让低层去实现，同时又要在高层加载（或实例化）低层的类时，就必须要通过线程上下文类加载器来帮助高层的类加载器找到并加载该类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 1.设置</span></span><br><span class="line">   Thread.currentThread().setContextClassLoader(targetTccl);</span><br><span class="line">   <span class="comment">// 2.使用</span></span><br><span class="line">   myMethod();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 3.还原</span></span><br><span class="line">   Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">扩展-3</font>：MySQL 驱动实现类的加载。</p>
<p>添加 mysql-connector-java 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载驱动</span></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Driver driver = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver: "</span> + driver.getClass() + <span class="string">", loader: "</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"当前线程上下文类加载器："</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader 的类加载器："</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriver, loader: sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">当前线程上下文类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2 # 应用类加载器加载</span><br><span class="line">ServiceLoader 的类加载器：null # 位于 rt.jar 包中属于启动类加载器加载</span><br></pre></td></tr></table></figure>

<p><font color="red">JVM 是怎么可以通过一个 Driver 接口就找到具体的实现类呢？</font>ServiceLoader 类的文档说明：</p>
<p><img src="ServiceLoader%E5%8A%A0%E8%BD%BD%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png" alt=""></p>
<p>我们可以在 mysql-connector-java-5.1.47.jar 文件下找到对应 ServiceLoader 类的文档中描述的配置信息，也就知道了上述打印结果的 Driver 接口实现类从何而来。</p>
<p><img src="MySQL%E7%9A%84Driver%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE.png" alt=""></p>
<h2 id="3-6-自定义类加载器"><a href="#3-6-自定义类加载器" class="headerlink" title="3.6 自定义类加载器"></a>3.6 自定义类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest16</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将应用类加载器当做该类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest16</span><span class="params">(ClassLoader parent, String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyTest16&#123;"</span> +</span><br><span class="line">                <span class="string">"classLoaderName='"</span> + classLoaderName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">"findClass invoked: "</span> + className); <span class="comment">// 验证是否使用我们自定义的类加载器</span></span><br><span class="line">        System.out.println(<span class="string">"class loader name: "</span> + <span class="keyword">this</span>.classLoaderName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">this</span>.loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        className = className.replace(<span class="string">"."</span>, <span class="string">"\\"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="keyword">this</span>.path + className + <span class="keyword">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((ch = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">        <span class="comment">// 从默认的文件夹下进行加载</span></span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        System.out.println(object1);</span><br><span class="line">        System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line">        <span class="comment">// 从默认的文件夹下进行加载</span></span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"class2: "</span> + clazz2.hashCode());</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        System.out.println(object2.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class1: 460141958</span><br><span class="line">MyTest15</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">class2: 460141958</span><br><span class="line">MyTest15</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>根据以上的执行结果，可见并没有使用我们自定义的类加载器进行加载，而是由应用类加载器所加载的，这是为什么？因为我们自己所定义的类加载器是将应用类加载器所加载作为父类加载器，根据双亲委派模型可知是由我们自定义类加载器的父类加载器，即应用类加载器所加载。而且因为 loader1 与 loader2 都是同一个父类加载器所以 class1.hashCode 与 class2.hashCode 的值是一样的。</p>
<p>接下来对上述 main 方法进行修改下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line"><span class="comment">// 从指定的文件夹下进行加载</span></span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">Object object = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line"><span class="comment">// 从指定的文件夹下进行加载</span></span><br><span class="line">loader2.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class2: "</span> + clazz2.hashCode());</span><br><span class="line">Object object2 = clazz2.newInstance();</span><br><span class="line">System.out.println(object2);</span><br><span class="line">System.out.println(object2.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：执行前在将原有默认路径下的 MyTest15.class 文件拷贝至指定的路径下的同时，必须将原有路径下的 MyTest15.class 文件删除，如果不删除，执行结果与之前一样，因为 loader1 与 loader2 同属同一个父类加载器，即应用类加载器，而应用类加载器默认是加载用户类路径 ClassPath 上所指定的类，因此要想验证自定义类加载器必须删除 MyTest15.class 文件。</p>
</blockquote>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8MyTest16.png" alt=""></p>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 1956725890</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line"></span><br><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader2</span><br><span class="line">class2: 21685669</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader2&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>可见，我们自定义的类加载器生效了，那么为什么 class1.hashCode 与 class2.hashCode 不一致呢？这里涉及到<font color="red">类加载器的命名空间</font>问题。</p>
<div class="note danger">
            <p>1）每个类加载器都有自己的命名空间，命名空间由<font color="red">该加载器及所有父类加载器</font>所加载的类组成。<br>2）在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。<br>3）在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
          </div>

<p>接下来，我们继续对代码进行改造，只需修改下面一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在上述代码中的构造方法中添加 loader1 作为父类加载器。</span></span><br><span class="line"> MyTest16 loader2 = <span class="keyword">new</span> MyTest16(loader1, <span class="string">"loader2"</span>);</span><br></pre></td></tr></table></figure>

<p>注意执行前保证当前用户类路径下没有 MyTest15.class 文件，即删除 C:\Users\westboy\IdeaProjects\jvm-learning\shengsiyuan-jvm\target\classes\ 下的 MyTest15.class 文件，并且保存到指定路径，执行后结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: <span class="number">1956725890</span></span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=<span class="string">'loader1'</span>&#125;</span><br><span class="line"></span><br><span class="line">class2: <span class="number">1956725890</span></span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=<span class="string">'loader1'</span>&#125;</span><br></pre></td></tr></table></figure>


<p>分析：loader1 初次加载 MyTest15，委托给父类加载器，即应用类加载器，但是当前用户类路径下没有 MyTest15.class 文件（被我们删除了），所以 loader1 自己去使用我们自定义的类加载器去加载，并加载成功。当 loader2 进行继续加载时，因为其父类加载器被指定为 loader1，而 loader1 已经加载了 MyTest15，所以 class1.hashCode 与 class2.hashCode 相同。</p>
<div class="note danger">
            <p>类加载器命名空间扩展：同一个命名空间内的类是相互可见的。<font color="red">子类加载器的命名空间包含所有父类加载器的命名空间，因此子类加载器所加载的类能够访问父类加载器所加载的类。而由父类加载器所加载的类无法访问子类加载器所加载的类</font>。如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见。</p>
          </div>

<p>接下来，予以验证。</p>
<p><strong><font color="blue">验证第一阶段：基础夯实阶段</font></strong></p>
<p>先添加两个示例类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="comment">// MySample 中主动引用 MyCat。</span></span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本示例的用户当前类路径：C:\\Users\\westboy\\IdeaProjects\\jvm-learning\\shengsiyuan-jvm\\target\\classes\\，指定路径为：D:\\jvm\\。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用上述自定义类加载器加载类。</span></span><br><span class="line">    MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">    loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"com.westboy.MySample"</span>);</span><br><span class="line">    System.out.println(<span class="string">"class: "</span> + clazz.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果注释掉该行，那么并不会实例化 MySample 对象，即 MySample 构造方法不会被调用，</span></span><br><span class="line">    <span class="comment">// 因此不会实例化 MyCat 对象，即没有对 MyCat 进行主动使用，这里就不会加载 MyCat Class。</span></span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>MySample 与 MyCat 类都是应用类加载器进行加载，前面内容已经解释的很清楚，不用赘述。</p>
<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/westboy/MyCat</span><br><span class="line">  at com.westboy.MySample.&lt;init&gt;(MySample.java:12)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">  at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">  at com.westboy.MyTest17.main(MyTest17.java:12)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.westboy.MyCat</span><br><span class="line">  at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">  at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">  ... 7 more</span><br></pre></td></tr></table></figure>

<p>MyCat 类加载是由加载了 MySample 类的类加载器，即应用加载器所尝试加载，但是由于用户当前类路径下的 MySample.class 文件已经被删除，所以找不到，就抛出异常。</p>
<p><font color="blue">情况-3</font>：只删除用户当前类路径下的 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>MySample 类由用户自定义加载器进行加载，是因为在双亲委派模型下，其父类加载器，即应用类加载器在当前用户路径下找不到 MySample.class 文件，所以由自定义类加载器去加载。而 MyCat 类的加载，在其父类加载器，即应用类加载器在当前用户路径下可以找到 MyCat.class 文件，所以由应用类加载器所加载。</p>
<p><font color="blue">情况-4</font>：删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径存在 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">findClass invoked: com.westboy.MyCat</span><br><span class="line">class loader name: loader1</span><br><span class="line">MyCat is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>MySample 与 MyCat 类都是用户自定义加载器进行加载，前面内容已经解释的很清楚，不用赘述。</p>
<p><strong><font color="blue">验证第二阶段：父类无法访问子类</font></strong></p>
<p>修改 MyCat 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());、</span><br><span class="line">        System.out.println(<span class="string">"from MyCat: "</span> + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MyCat: class com.westboy.MySample</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/westboy/MySample</span><br><span class="line">  at com.westboy.MyCat.&lt;init&gt;(MyCat.java:6)</span><br><span class="line">  at com.westboy.MySample.&lt;init&gt;(MySample.java:12)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">  at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">  at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">  at com.westboy.MyTest17.main(MyTest17.java:12)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.westboy.MySample</span><br><span class="line">  at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">  at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">  at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">  ... 8 more</span><br></pre></td></tr></table></figure>

<p>分析结果：MySample 类由自定义类加载器加载，MyCat 类由应用类加载器加载，而应用类加载器加载是自定义类加载器加载的父类加载器，所以根据类加载器的命名空间的内容得知，父类加载器是访问不到子类加载器所加载的类。所以在由父类加载器所加载的 MyCat 类去访问由子类加载器所加载的 MySample 类时是访问不到的，因此抛出异常。</p>
<p><strong><font color="blue">验证第三阶段：子类可以访问父类</font></strong></p>
<p>MyCat 还原至第一阶段，修改 MySample 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded by: "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-1</font>：未删除用户当前类路径下的 MySample.class 和 MyCat.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class: 1163157884</span><br><span class="line">MySample is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MySample: class com.westboy.MyCat</span><br></pre></td></tr></table></figure>

<p><font color="blue">情况-2</font>：只删除用户当前类路径下的 MySample.class 文件，指定路径替换为新的 MySample.class 和 MyCat.class 文件，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MySample</span><br><span class="line">class loader name: loader1</span><br><span class="line">class: 356573597</span><br><span class="line">MySample is loaded by: MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line">MyCat is loaded by: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">from MySample: class com.westboy.MyCat</span><br></pre></td></tr></table></figure>

<p>分析结果：MySample 类由自定义类加载器加载，MyCat 类由应用类加载器加载，而应用类加载器加载是自定义类加载器加载的父类加载器，所以根据类加载器的命名空间的内容得知，子类加载器是可以访问父类加载器所加载的类。所以在由子类加载器所加载的 MySample 类中去访问由父类加载器所加载的 MyCat 类时是可以访问的，因此可以正常访问，并不会抛出异常。</p>
<p><strong><font color="blue">验证第四阶段：两个之间没有直接或间接的父子关系的加载器相互不可见</font></strong></p>
<p>创建示例类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyPerson myPerson;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处为什么设置参数为 Object？原因见下代码中的分析。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object Object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myPerson = (MyPerson) Object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">    MyTest16 loader2 = <span class="keyword">new</span> MyTest16(<span class="string">"loader2"</span>);</span><br><span class="line"></span><br><span class="line">    loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">    loader2.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyPerson"</span>);</span><br><span class="line">    Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"com.westboy.MyPerson"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">    Object object1 = clazz1.newInstance();</span><br><span class="line">    Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 MyPerson 类的 setMyPerson 的传参类型设置为 MyPerson，此处修改传参类型为 MyPerson.class，在运行时就会抛出异常：NoClassDefFoundError，</span></span><br><span class="line">    <span class="comment">// 因为此处为应用类加载器去加载 MyPerson 类，又因为我们已经删除了当前用户类路径下的 MyPerson.class 文件，所以就会抛出异常。</span></span><br><span class="line">    <span class="comment">// 这就是为什么 MyPerson 的 setMyPerson 方法传参设置为 Object 的奥妙。</span></span><br><span class="line">    Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object.class);</span><br><span class="line">    method.invoke(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将当前用户类路径下的 MyPerson.class 文件<font color="red">剪切</font>至指定类路径下，并执行，执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyPerson</span><br><span class="line">class loader name: loader1</span><br><span class="line">findClass invoked: com.westboy.MyPerson</span><br><span class="line">class loader name: loader2</span><br><span class="line">false</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">  at com.westboy.MyTest21.main(MyTest21.java:23)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.westboy.MyPerson cannot be cast to com.westboy.MyPerson</span><br><span class="line">  at com.westboy.MyPerson.setMyPerson(MyPerson.java:8)</span><br><span class="line">  ... 5 more</span><br></pre></td></tr></table></figure>

<p>将会发下一个奇怪的错误：<font color="red">com.westboy.MyPerson</font> cannot be cast to <font color="red">com.westboy.MyPerson</font>。为什么呢？看看标题，仔细分析。</p>
<h1 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4 类的卸载"></a>4 类的卸载</h1><p>当类被加载、连接和初始化后，它的生命周期就开始了。当代表类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，类在方法区内数据也会被卸载，从而结束类的生命周期。</p>
<p><font color="red">一个类何时结束生命周期，取决于代表它的 Class 对象何时结束生命周期</font>。</p>
<p><font color="red">由 Java 虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载</font>。前面已经介绍过，Java 虚拟机自带的类加载器包括启动类加载器、扩展类加载器和应用/系统类加载器。Java 虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的 Class 对象，因此这些 Class 对象始终是可触及的。<br><font color="red">由用户自定义的类加载器所加载的类是可以被卸载的</font>。</p>
<p>类的卸载示例，修改之前使用的例子，并添加 VM 参数：-XX:+TraceClassUnloading，打印类的卸载信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyTest16 loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">Object object1 = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">loader1 = <span class="keyword">null</span>;</span><br><span class="line">clazz1 = <span class="keyword">null</span>;</span><br><span class="line">object1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">loader1 = <span class="keyword">new</span> MyTest16(<span class="string">"loader1"</span>);</span><br><span class="line">loader1.setPath(<span class="string">"D:\\jvm\\"</span>);</span><br><span class="line">clazz1 = loader1.loadClass(<span class="string">"com.westboy.MyTest15"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"class1: "</span> + clazz1.hashCode());</span><br><span class="line">object1 = clazz1.newInstance();</span><br><span class="line">System.out.println(object1);</span><br><span class="line">System.out.println(object1.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 1956725890</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br><span class="line"></span><br><span class="line">[Unloading class com.westboy.MyTest15 0x00000007c0061028]</span><br><span class="line"></span><br><span class="line">findClass invoked: com.westboy.MyTest15</span><br><span class="line">class loader name: loader1</span><br><span class="line">class1: 21685669</span><br><span class="line">MyTest15</span><br><span class="line">MyTest16&#123;classLoaderName=&apos;loader1&apos;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过 Java 自带的 VisualVM 工具观察到，在观察之前将代码稍微修改下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">loader1 = <span class="keyword">null</span>;</span><br><span class="line">clazz1 = <span class="keyword">null</span>;</span><br><span class="line">object1 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 让程序保持运行</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>VisualVM 监控信息：</p>
<p><img src="%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD%E7%9B%91%E6%8E%A7%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h1 id="5-Jar-Hell-问题及诊断"><a href="#5-Jar-Hell-问题及诊断" class="headerlink" title="5 Jar Hell 问题及诊断"></a>5 Jar Hell 问题及诊断</h1><p>当一个类或者一个资源文件存在多个 Jar 中，就会存在 Jar Hell 问题。</p>
<p>可以通过以下代码来诊断问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">String reosurceName = <span class="string">"xxx.class"</span>;</span><br><span class="line">Enumeration&lt;URL&gt; urls = classLoader.getResources(reosurceName);</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">    URL url = urls.nextElement();</span><br><span class="line">    System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/JVM-03-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/26/JVM-03-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">JVM-03-类文件结构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-26 16:57:36" itemprop="dateCreated datePublished" datetime="2019-11-26T16:57:36+08:00">2019-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Class 文件是一组以 8 字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符。</p>
<p>在 Java 虚拟机规范的规定，Class 文件格式采用一种类似 C 语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：<font color="red">无符号数</font>和<font color="red">表</font>。<font color="red">无符号数</font>属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。<font color="red">表</font>由多个无符号数或者其他表作为数据项构成复合数据类型，所有表都以 _info 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。</p>
<figure class="highlight shell"><figcaption><span>Class 文件格式</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                                # 魔数</span><br><span class="line">    u2             minor_version;                        # 主版本号</span><br><span class="line">    u2             major_version;                        # 次版本号</span><br><span class="line">    u2             constant_pool_count;                  # 常量池集合大小（索引值从 1 开始，为 0 即不引用任何一个常量池，实际大小为 = constant_pool_count - 1）</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1]; # 常量池集合（也称作常量表）</span><br><span class="line">    u2             access_flags;                         # 访问标志</span><br><span class="line">    u2             this_class;                           # 类索引 </span><br><span class="line">    u2             super_class;                          # 父类索引</span><br><span class="line">    u2             interfaces_count;                     # 接口索引集合大小</span><br><span class="line">    u2             interfaces[interfaces_count];         # 接口索引集合</span><br><span class="line">    u2             fields_count;                         # 字段表集合大小</span><br><span class="line">    field_info     fields[fields_count];                 # 字段表集合</span><br><span class="line">    u2             methods_count;                        # 方法表集合大小</span><br><span class="line">    method_info    methods[methods_count];               # 方法表集合</span><br><span class="line">    u2             attributes_count;                     # 属性表集合大小</span><br><span class="line">    attribute_info attributes[attributes_count];         # 属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-魔数与-Class-文件版本"><a href="#1-魔数与-Class-文件版本" class="headerlink" title="1 魔数与 Class 文件版本"></a>1 魔数与 Class 文件版本</h1><p>刚开始 4 个字节为魔数，魔数之后的 4 个字节为版本信息。</p>
<!-- <img src="案例1.png" width="850px"/> -->

<h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2 常量池"></a>2 常量池</h1><div class="note warning">
            <p><font color="red">注意常量池存储的并不都全是不变的量</font>。一个 Java 类中定义的很多信息都是由常量池来维护和描述的，因此可以将常量池看作是 class 文件的资源仓库，比如 Java 类中定义的方法与变量信息，都是存储在常量池中。</p>
          </div>

<p>主要存放两大类常量：<font color="red">字面量</font>和<font color="red">符号引用</font>。字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ol>
<li>类和接口的全限定名；</li>
<li>字段的名称和描述符；</li>
<li>方法的名称和描述符。</li>
</ol>
<p>Java 代码在进行 Javac 编译时是在虚拟机加载 Class 文件的时候进行<font color="red">动态连接</font>。也就是说，在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址之中。</p>
<p>常量池中的每一项常量都是一个表，在 JDK 1.7 之后共有 14 中常量类型，<font color="red">不同类型的常量表结构不相同</font>，所以常量池是最烦琐的数据。</p>
<p><img src="%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB.png" alt=""></p>
<blockquote>
<p>在 JDK 1.7 中为了更好的支持动态语言调用，又额外增加了最后 3 种。</p>
</blockquote>
<!-- <img src="案例2.png" width="850px"/> -->

<h1 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3 访问标志"></a>3 访问标志</h1><p>在常量池结束之后，紧接着的两个字节代表访问标志，访问标志用于识别一些<font color="red">类或者接口</font>层次的访问信息。</p>
<img src="访问标志.png" width="700px"/>

<blockquote>
<p>访问标志中一共 16 个标志位可以使用，当前只定义了其中 8 个，没有使用到的标志位要求一律为 0。</p>
</blockquote>
<!-- <img src="案例3.png" width="850px"/> -->

<h1 id="4-类索引、父类索引与接口索引集合"><a href="#4-类索引、父类索引与接口索引集合" class="headerlink" title="4 类索引、父类索引与接口索引集合"></a>4 类索引、父类索引与接口索引集合</h1><!-- <img src="案例4.png" width="850px"/> -->

<h1 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5 字段表集合"></a>5 字段表集合</h1><p>字段表用于描述<font color="red">类或者接口</font>中声明的变量。<font color="red">字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量</font>。</p>
<p>字段包含信息：</p>
<ol>
<li>字段的作用域：public、private、protected 修饰符。</li>
<li>是实例变量还是类变量：static 修饰符。</li>
<li>可变性：final 修饰符。</li>
<li>并发可见性：volatile 修饰符，是否强制从主内存读写。</li>
<li>可否被序列化：transient 修饰符。</li>
<li>字段数据类型：基本类型、对象、数组。</li>
<li>字段名称。</li>
</ol>
<p>字段表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2             access_flags;                 # 字段访问标志</span><br><span class="line">    u2             name_index;                   # 字段的简单名称索引</span><br><span class="line">    u2             descriptor_index;             # 字段的描述符索引</span><br><span class="line">    u2             attributes_count;             # 属性表集合大小</span><br><span class="line">    attribute_info attributes[attributes_count]; # 属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段访问标志：</p>
<!-- ![](字段访问标志.png) -->

<!-- <img src="字段访问标志.png" width="380px"/> -->


<p>注意：在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED 三个标志最多只能选择其一，ACC_FINAL 和 ACC_VOLATILE 不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL 标志，这些都是由 Java 本身的语音规则所决定的。当一个字段没有访问修饰符时，即包级访问，访问标志为：0x0000。</p>
<p>跟随 access_flags 访问标志的是两项索引值：name_index 和 descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。</p>
<p>扩展：全限定名、简单名称和描述符解释：</p>
<ol>
<li><font color="green">全限定名</font>：比如：com/westboy/bytecode/Demo; 就是一个全限定名，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</li>
<li><font color="green">简单名称</font>：指没有类型和参数修饰的方法或者字段名称，比如 inc() 方法和 m 字段的简单名称分别是 inc 和 m。</li>
<li><font color="green">描述符</font>：在 Java 虚拟机规范中，每个变量或字段都有描述信息，描述信息主要作用是描述字段的数据类型、方法的参数列表（包括数量、类型和顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的 void 类型都用一个大写字符表示，对象类型则使用字符 L 加对象的全限定名来表示。为了压缩字节码文件的体积，<font color="red">对于基本数据类型，JVM 都只使用一个大写字母来表示，如下所示：B - byte，C - char，D - double，F -float，I - int，J - Long，S -short，Z - boolean，V - void，L - 对象类型</font>，如 Ljava/lang/String。<font color="red">对于数组类型来说，每一个维度使用一个前置的 [ 来表示</font>，如 int[] 被记录为“[I”，String[][] 被记录为：“[[Ljava/lang/String;”。<font color="red">用描述符描述方法时，按照先参数列表，后返回值的顺序来描述</font>。参数列表按照参数的严格顺序放在一组括号内，如方法：int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) 的描述符为：“([CII[CIII)I”</li>
</ol>
<!-- <img src="案例5.png" width="850px"/> -->

<h1 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6 方法表集合"></a>6 方法表集合</h1><p>方法表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">    u2             access_flags;                 # 方法访问标志</span><br><span class="line">    u2             name_index;                   # 方法的名称索引</span><br><span class="line">    u2             descriptor_index;             # 方法的描述符索引</span><br><span class="line">    u2             attributes_count;             # 属性表集合大小</span><br><span class="line">    attribute_info attributes[attributes_count]; # 属性表集合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法访问标志：</p>
<img src="方法访问标志.png" width="450px"/>
<!-- ![](方法访问标志.png) -->

<!-- <img src="案例6.png" width="850px"/> -->

<h1 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7 属性表集合"></a>7 属性表集合</h1><p>在 Class 文件、字段表和方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<blockquote>
<p>与 Class 文件中其他数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息（即<font color="red">编译器也可以实现自定义的属性写入 Class 文件，供运行时使用</font>），Java 虚拟机运行时会忽略掉它不认识的属性。</p>
</blockquote>
<p>虚拟机规范预定义的属性：</p>
<p><img src="%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<p>对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而<font color="red">属性值的结构则是完全自定义的</font>，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可。</p>
<h2 id="7-1-Code-属性"><a href="#7-1-Code-属性" class="headerlink" title="7.1 Code 属性"></a>7.1 Code 属性</h2><p>Code 属性的作用是保存该方法的结构。但<font color="red">并非所有的方法表都必须存在这个属性</font>，譬如接口或者抽象类中的方法就不存在 Code 属性。</p>
<p>Code 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                     # 属性名称索引，指向  CONSTANT_Utf8_info 类型常量的索引，常量固定值为 Code</span><br><span class="line">    u4 attribute_length;                         # 属性值的长度，由于属性名称索引与属性长度一共为 6 字节，所以属性值长度固定为整个属性表长度 - 6</span><br><span class="line">    u2 max_stack;                                # 代表操作数栈深度的最大值，虚拟机运行时需要根据这个值来分配栈帧中的操作栈深度                      </span><br><span class="line">    u2 max_locals;                               # 代表局部变量所需要的存储空间，单位是 Slot，对于 byte、char、float、int、short、boolean 和 returnAddress 等</span><br><span class="line">                                                 # 长度不超过 32 位的数据类型，每个局部变量占用 1 个 Slot，而 double 和 long 这两种 64 位数据类型则需要两个 Slot 来存放</span><br><span class="line">    u4 code_length;                              # 字节码长度，理论最大值可以达到 2^32-1，但是虚拟机规范明确规定不允许超过 65535 条字节指令，即实际只使用了 u2 长度</span><br><span class="line">    u1 code[code_length];                        # 存储字节码指令的一系列字节流，每个指令就是一个 u1 类型的单字节</span><br><span class="line">    u2 exception_table_length;                   #</span><br><span class="line">    &#123;   u2 start_pc;                             #</span><br><span class="line">        u2 end_pc;                               #</span><br><span class="line">        u2 handler_pc;                           #</span><br><span class="line">        u2 catch_type;                           #</span><br><span class="line">    &#125; exception_table[exception_table_length];   # 异常处理表集合，当字节码在 [start_pc, end_pc) 出现类型为 catch_type 或者子类的异常，则转到 handler_pc 进行处理</span><br><span class="line">    u2 attributes_count;                         #</span><br><span class="line">    attribute_info attributes[attributes_count]; #</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-Exceptions-属性"><a href="#7-2-Exceptions-属性" class="headerlink" title="7.2 Exceptions 属性"></a>7.2 Exceptions 属性</h2><p>Exceptions 属性是在方法表中与 Code 属性平级的一项属性，<font color="red">注意不要与 Code 属性中的异常表产生混淆</font>。Exceptions 属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时在 throws 关键字后面列举的异常。</p>
<p>Exceptions 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exceptions_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                        # 属性名称索引</span><br><span class="line">    u4 attribute_length;                            # 属性值的长度</span><br><span class="line">    u2 number_of_exceptions;                        # 表示可能抛出 number_of_exceptions 种受检查异常，每一种受检查异常使用一个 exception_index_table 项表示</span><br><span class="line">    u2 exception_index_table[number_of_exceptions]; # 指向常量池中 CONSTANT_Utf8_info 型常量的索引，代表了该受检查的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="7-3-LineNumberTable-属性"><a href="#7-3-LineNumberTable-属性" class="headerlink" title="7.3 LineNumberTable 属性"></a>7.3 LineNumberTable 属性</h2><p>LineNumberTable 属性用于描述 Java 源码行号与字节码行号（字节码的偏移量）之间的对应关系。它<font color="red">并不是运行时必须的属性</font>，但默认会生成到 Class 文件之中，<font color="red">可以在 Javac 中分别使用 -g:none 或 -g:lines 选项来取消或要求生成这些信息</font>。如果选择不生成 LineNumberTable 属性，对程序运行产生的最主要影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。</p>
<p>LineNumberTable 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                       # 属性名称索引</span><br><span class="line">    u4 attribute_length;                           # 属性值的长度</span><br><span class="line">    u2 line_number_table_length;                   # 映射集合大小</span><br><span class="line">    &#123;   u2 start_pc;                               # 字节码行号</span><br><span class="line">        u2 line_number;                            # Java 源码行号</span><br><span class="line">    &#125; line_number_table[line_number_table_length]; # 映射</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-LocalVariableTable-属性"><a href="#7-4-LocalVariableTable-属性" class="headerlink" title="7.4 LocalVariableTable 属性"></a>7.4 LocalVariableTable 属性</h2><p>LocalVariableTable 属性用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系，它<font color="red">也不是运行时必需的属性</font>，但默认会生产到 Class 文件中，<font color="red">可以在 Javac 中分别使用 -g:none 或 -g:vars 选项来取消或要求生成这项选项</font>。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有参数名称都将会丢失，IDE 将会使用诸如 args0，args1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
<p>LocalVariableTable 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;                             # 属性名称索引</span><br><span class="line">    u4 attribute_length;                                 # 属性值的长度</span><br><span class="line">    u2 local_variable_table_length;                      # 局部变量个数</span><br><span class="line">    &#123;   u2 start_pc;                                     # 局部变量的生命周期开始的字节码偏移量</span><br><span class="line">        u2 length;                                       # 局部变量的生命周期的作用范围覆盖的长度</span><br><span class="line">        u2 name_index;                                   # 指向常量池中 CONSTANT_Utf8_info 型常量的索引</span><br><span class="line">        u2 descriptor_index;                             # 指向常量池中 CONSTANT_Utf8_info 型常量的索引</span><br><span class="line">        u2 index;                                        # 该局部变量在局部变量表中的 Slot 位置，当这个变量数据类型是 64 位类型时（double 和 long），它占用的 Slot 为 index 和 index+1 两个</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 JDK 1.5 引入泛型之后，LocalVariableTable 属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与 LocalVariable 非常相似，仅仅是把记录的字段描述符的 descriptor_index 替换成了字段的特征签名（Signature），对于非泛型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉，描述符就不能准确地描述泛型了，因此出现了 LocalVariableTypeTable。</p>
</blockquote>
<h2 id="7-5-SourceFile-属性"><a href="#7-5-SourceFile-属性" class="headerlink" title="7.5 SourceFile 属性"></a>7.5 SourceFile 属性</h2><p>SourceFile 属性用于记录生成这个 Class 文件的源码文件名称。这个属性也是可选的，可以分别使用 Javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性。</p>
<p>SourceFile 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; # 属性名称索引</span><br><span class="line">    u4 attribute_length;     # 属性值的长度，同理，属性值长度固定为整个属性表长度 - 6</span><br><span class="line">    u2 sourcefile_index;     # 指向常量池中 CONSTANT_Utf8_info 型常量的索引，常量值是源码文件的文件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-ConstantValue-属性"><a href="#7-6-ConstantValue-属性" class="headerlink" title="7.6 ConstantValue 属性"></a>7.6 ConstantValue 属性</h2><p>ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 &lt;init&gt; 方法中进行的；而对于类变量，则有<font color="red">两种方式</font>可以选择：<font color="red">在类构造器 &lt;clinit&gt; 方法中</font>或者<font color="red">使用 ConstantValue 属性</font>。</p>
<p><font color="red">目前 Sun Javac 编译器的选择是</font>：如果同时使用 final 和 static 来修饰一个变量，并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就生成 ConstantValue 属性来进行初始化，否则，将会在 &lt;clinit&gt; 方法中进行初始化。</p>
<blockquote>
<p>虽然有 final 关键字才符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了 ACC_FINAL 标志，只要求了有 ConstantValue 属性的字段必须设置 ACC_STATIC 标志，对 final 关键字的要求是 Javac 编译器自己加入的限制。因为 Class 文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以 ConstantValue 的属性值也只能限定于基本类型和 java.lang.String 类型。</p>
</blockquote>
<p>ConstantValue 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute &#123;</span><br><span class="line">    u2 attribute_name_index; # 属性名称索引</span><br><span class="line">    u4 attribute_length;     # 属性值的长度，ConstantValue 属性是一个定长属性，它的 attribute_length 数据项必须固定为 2</span><br><span class="line">    u2 constantvalue_index;  # 常量池中一个字面量常量的引用，根据字段类型的不同，</span><br><span class="line">                             # 字面量可以是 CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info 常量中的一种。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-7-InnerClasses-属性"><a href="#7-7-InnerClasses-属性" class="headerlink" title="7.7 InnerClasses 属性"></a>7.7 InnerClasses 属性</h2><p>InnerClasses 属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClasses 属性。</p>
<p>InnerClasses 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InnerClasses_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;          # 属性名称索引</span><br><span class="line">    u4 attribute_length;              # 属性值的长度</span><br><span class="line">    u2 number_of_classes;             # 记录有多少个内部类</span><br><span class="line">    &#123;   u2 inner_class_info_index;    # 内部类的符号引用</span><br><span class="line">        u2 outer_class_info_index;    # 诉诸类的符号引用</span><br><span class="line">        u2 inner_name_index;          # 指向常量池中的 CONSTANT_Utf8_info 型常量的索引，代表内部类的名称，如果是匿名内部类，值为 0</span><br><span class="line">        u2 inner_class_access_flags;  # 内部类的访问标志</span><br><span class="line">    &#125; classes[number_of_classes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类的访问标志：</p>
<!-- ![](内部类访问标志.png) -->

<img src="./内部类访问标志.png" width="420px"/>


<h2 id="7-8-Deprecated-及-Synthetic-属性"><a href="#7-8-Deprecated-及-Synthetic-属性" class="headerlink" title="7.8 Deprecated 及 Synthetic 属性"></a>7.8 Deprecated 及 Synthetic 属性</h2><p>Deprecated 及 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p>
<ul>
<li>Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，可以通过在代码中使用 @deprecated 注释进行设置。</li>
<li>Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的。</li>
</ul>
<p>Deprecated 及 Synthetic 属性表结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Synthetic_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length; # 值为 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deprecated_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length; # 值为 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-9-StackMapTable-属性"><a href="#7-9-StackMapTable-属性" class="headerlink" title="7.9 StackMapTable 属性"></a>7.9 StackMapTable 属性</h2><h2 id="7-10-Signature-属性"><a href="#7-10-Signature-属性" class="headerlink" title="7.10 Signature 属性"></a>7.10 Signature 属性</h2><h2 id="7-11-BootstrapMethods-属性"><a href="#7-11-BootstrapMethods-属性" class="headerlink" title="7.11 BootstrapMethods 属性"></a>7.11 BootstrapMethods 属性</h2><h1 id="8-案例分析"><a href="#8-案例分析" class="headerlink" title="8 案例分析"></a>8 案例分析</h1><h2 id="8-1-准备"><a href="#8-1-准备" class="headerlink" title="8.1 准备"></a>8.1 准备</h2><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看编译后的二进制文件，可以通过 Hex Fiend 软件将二进制转换成十六进制，方便后续分析。</p>
<img src="十六进制文件.png" width="850px"/>

<p>再通过 javap -verbose 命令反解析信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># javap -verbose target/classes/com/westboy/bytecode/MyTest1.class</span><br><span class="line">Classfile /Users/westboy/IdeaProjects/personal/java-learning/shengsiyuan-jvm/target/classes/com/westboy/bytecode/MyTest1.class</span><br><span class="line">  Last modified 2019-11-24; size 487 bytes</span><br><span class="line">  MD5 checksum d4d9ee601106058691f328f370e8cc59</span><br><span class="line">  Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class com.westboy.bytecode.MyTest1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/westboy/bytecode/MyTest1.a:I</span><br><span class="line">   #3 = Class              #22            // com/westboy/bytecode/MyTest1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/westboy/bytecode/MyTest1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               MyTest1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/westboy/bytecode/MyTest1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.westboy.bytecode.MyTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 9: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  this   Lcom/westboy/bytecode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/westboy/bytecode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 16: 0</span><br><span class="line">        line 17: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lcom/westboy/bytecode/MyTest1;</span><br><span class="line">            0       6     1     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest1.java&quot;</span><br></pre></td></tr></table></figure>

<p>接下来，我们将逐步分析这个反解析过程，看下这些二进制文件怎么映射到上述反解析的结果。</p>
<h2 id="8-2-总体结构"><a href="#8-2-总体结构" class="headerlink" title="8.2 总体结构"></a>8.2 总体结构</h2><p>根据 Class 文件格式依次标出各个字段对应的十六进制范围。</p>
<img src="案例分析-1.png" width="1000px"/>

<p>需要注意的是：</p>
<ul>
<li>从上图可以观察到占据 Class 文件空间最多的就是常量池与方法表。</li>
<li>常量池表集合实际大小 = constant_pool_count-1。</li>
<li>所有访问标志（类或接口的访问标志、方法的访问标志，字段的访问标志）均取它们组合的 &amp; 操作，比如：此示例中的类访问标志为 0X0021，根据访问标志的 &amp; 操作可以推到出该类的访问修饰符为 ACC_PUBLIC(0X0001) 与 ACC_SUPER(0X0020) 组合。</li>
<li>如果当前表的集合大小为 0 时，后续是没有任何表信息相关的内容，紧挨着的是下一个无符号数或者表。</li>
</ul>
<h2 id="8-3-常量池分析"><a href="#8-3-常量池分析" class="headerlink" title="8.3 常量池分析"></a>8.3 常量池分析</h2><img src="案例分析-2.png" width="1000px"/>

<h2 id="8-4-方法表分析"><a href="#8-4-方法表分析" class="headerlink" title="8.4 方法表分析"></a>8.4 方法表分析</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/Tomcat-%E5%A4%9A%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/Tomcat-%E5%A4%9A%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">Tomcat-多种部署方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 22:53:47" itemprop="dateCreated datePublished" datetime="2019-11-12T22:53:47+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web-%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index">
                    <span itemprop="name">Web 容器</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-默认配置文件"><a href="#1-默认配置文件" class="headerlink" title="1 默认配置文件"></a>1 默认配置文件</h1><p>基于 Tomcat 8.5.46 的 conf 目录下的 server.xml 配置文件：</p>
<figure class="highlight xml"><figcaption><span>conf/server.xml 去除掉注释信息后文件内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span> <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span> <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span> <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span> <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- name 属性指定虚拟主机名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- appBase 为存放应用程序的目录 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- unpackWARs 如果为 true，则 Tomcat 会自动将 WAR 文件解压，否则不解压，直接从 WAR 文件中运行应用程序 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- path 表示此应用程序的 url 的前缀 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- docBase 应用程序的路径或者是 WAR 文件存放的路径 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- reloadable 这个属性非常重要，如果为 true，则 Tomcat 会自动检测应用程序的 /WEB-INF/lib 和 /WEB-INF/classes 目录的变化，自动装载新的应用程序，我们可以在不重起 Tomcat 的情况下改变应用程序 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;Context path="" docBase="..." reloadable="true"/&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="2-多个端口指向同一个应用"><a href="#2-多个端口指向同一个应用" class="headerlink" title="2 多个端口指向同一个应用"></a>2 多个端口指向同一个应用</h1><p>绑定多个 Connector 在上面的 server.xml 中添加：</p>
<figure class="highlight xml"><figcaption><span>conf/server.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8081"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>重新启动 Tomcat，如果有服务要重启服务，就会发现也可以用 127.0.0.1:8081 访问 8080 的项目。</p>
<h1 id="3-不同域名指向同一主机上的不同项目"><a href="#3-不同域名指向同一主机上的不同项目" class="headerlink" title="3 不同域名指向同一主机上的不同项目"></a>3 不同域名指向同一主机上的不同项目</h1><h2 id="3-1-应用准备"><a href="#3-1-应用准备" class="headerlink" title="3.1 应用准备"></a>3.1 应用准备</h2><p>复制 webapps 目录下的 MyWebApp 命名为 MyWebApp2（当做不同应用）：</p>
<img src="2-Tomcat配置.png" width="450px"/>

<h2 id="3-2-域名解析设置"><a href="#3-2-域名解析设置" class="headerlink" title="3.2 域名解析设置"></a>3.2 域名解析设置</h2><p>将两个不同的域名解析到同一个 IP 地址上，这个 IP 地址就是服务器的 IP 地址。</p>
<img src="2-域名解析配置.png" width="450px"/>

<h2 id="3-3-服务端设置"><a href="#3-3-服务端设置" class="headerlink" title="3.3 服务端设置"></a>3.3 服务端设置</h2><p>修改 Tomcat 文件目录下 conf/server.xml 文件：</p>
<figure class="highlight xml"><figcaption><span>conf/server.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 MyWebApp 的 docBase 路径，可以是绝对路径，也可以是相对路径，相对路径是基于 appBase 所指定的路径，注意前面没有 / --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"MyWebApp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost2"</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 MyWebApp2 的 docBase 路径，可以是绝对路径，也可以是相对路径，相对路径是基于 appBase 所指定的路径，注意前面没有 / --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"MyWebApp2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span> <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span> <span class="attr">pattern</span>=<span class="string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-结果验证"><a href="#3-4-结果验证" class="headerlink" title="3.4 结果验证"></a>3.4 结果验证</h2><p>此时去访问应用，会出现以下几种结果：</p>
<img src="2-访问结果-1.png" width="800px"/>

<p>这是为什么呢？先保留，我们先修改成我们希望的样子只需修改 Context 的 path 属性：</p>
<figure class="highlight xml"><figcaption><span>conf/server.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"t1"</span> <span class="attr">docBase</span>=<span class="string">"MyWebApp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"t2"</span> <span class="attr">docBase</span>=<span class="string">"MyWebApp2"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以实现通过指定域名访问不通项目了。</p>
<img src="2-访问结果-2.png" width="800px"/>


<h1 id="4-经典问题"><a href="#4-经典问题" class="headerlink" title="4 经典问题"></a>4 经典问题</h1><p>Tomcat 架构设计图：</p>
<img src="Tomcat的架构图.png" width="900px"/>

<p>那么如果我有两个应用需要部署，只有一个 Tomcat 实例，那么根据 Tomcat 的架构设计图以下三种部署方案：</p>
<img src="一个Tomcat实例两个应用部署方案.png" width="800px"/>

<p>其中方案一的比较简单，方案二可以参考<a href="#3-不同域名指向同一主机上的不同项目">不同域名指向同一主机上的不同项目</a>，方案三可以参考：<a href="https://my.oschina.net/lzwenme/blog/229035" target="_blank" rel="noopener">Tomcat 配置多个 Service，多个同名的应用运行在一个 tomcat 下</a>，至于部署的是相通应用还是不同应用无关紧要。</p>
<p>当然随着分布式服务的流行，Tomcat 都是内嵌于 SpringBoot 应用中的，所以目前对于 SpringBoot 中关于 Tomcat 的架构流程猜想如下。</p>
<img src="SpringBoot内嵌服务猜想.png" width="750px"/>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/JVM-02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/JVM-02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">JVM-02-垃圾收集器与内存分配策略</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 22:53:27" itemprop="dateCreated datePublished" datetime="2019-11-12T22:53:27+08:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-22 14:17:51" itemprop="dateModified" datetime="2019-11-22T14:17:51+08:00">2019-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-对象的存活判断"><a href="#1-对象的存活判断" class="headerlink" title="1 对象的存活判断"></a>1 对象的存活判断</h1><h2 id="1-1-存活判断算法"><a href="#1-1-存活判断算法" class="headerlink" title="1.1 存活判断算法"></a>1.1 存活判断算法</h2><h3 id="①-引用计数法"><a href="#①-引用计数法" class="headerlink" title="① 引用计数法"></a>① 引用计数法</h3><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减 1，任何时刻计数器为 0 的对象就是不可能再被使用的。优点：实现简单，判断效率高。缺点：JVM 里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<h3 id="②-可达性分析算法（Hotspot-JVM-采用的算法）"><a href="#②-可达性分析算法（Hotspot-JVM-采用的算法）" class="headerlink" title="② 可达性分析算法（Hotspot JVM 采用的算法）"></a>② 可达性分析算法（Hotspot JVM 采用的算法）</h3><p>通过一系列称之为 GC Roots 的对象作为起点，从这个节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连时（用图论的话来说，就是从 GC Roots 到这个对象不可达），则证明此对象是不可用的。</p>
<img src="./可达性分析算法.png" width="550px"/>


<p><font color="red">在 JVM 中哪些对象可以作为 GC Roots 对象呢？</font></p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。即方法的局部变量。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
</ol>
<p>注意：<font color="red">实例变量不能作为 GC Roots</font>。</p>
<h2 id="1-2-引用类型"><a href="#1-2-引用类型" class="headerlink" title="1.2 引用类型"></a>1.2 引用类型</h2><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用 4 种，这 4 种引用强度依次逐渐减弱。</p>
<ol>
<li><font color="red">强引用</font>：强引用就是指在程序代码之中普遍存在的，类似 Objectobj = new Object; 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li><font color="red">软引用</font>：软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 <code>SoftReference</code> 类来实现软引用。正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了，此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。</li>
<li><font color="red">弱引用</font>：弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供广 WeakReference 类来实现弱引用。弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉。</li>
<li><font color="red">虚引用</font>：虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK1.2 之后，提供了 PhantomReference 类来实现虚引用。</li>
</ol>
<h2 id="1-3-对象的生死存亡"><a href="#1-3-对象的生死存亡" class="headerlink" title="1.3 对象的生死存亡"></a>1.3 对象的生死存亡</h2><p><font color="red">在可达性分析算法中分析得出对象不可达的时，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少需要两次标记过程</font>：</p>
<ol>
<li>对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，会被第一次标记并筛选有必要执行 finalize 方法的对象。如果没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，都会被视为没有必要执行。</li>
<li>将筛选出的对象存放在 F-Queue 中，稍后由虚拟机自动建立的、低优先级的一个后台线程 Finalizer 去执行对象的 finalize 方法，但不承诺等待运行结束，原因是如果有个对象的 finalize 方法执行缓慢或是发生了死循环，可能导致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收系崩溃。finalize 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象在 finalize 方法中重新与引用链上的任何一个对象建立关联，那么在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那么基本上它就真的被回收了。</li>
</ol>
<p>执行示意图：</p>
<img src="./对象的生死存亡过程.png" width="750px"/>

<div class="note warning">
            <p>注意：任何一个对象的 finalize 方法都只会被系统自动调用一次。</p>
          </div>

<p>验证示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1. 对象可以在被 GC 时自我拯救</span></span><br><span class="line"><span class="comment">* 2. 这种自救的机会只有一次，因为一个对象的 finalize 方法最多只能被系统自动调用一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalizeDemo Hook = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> finalize <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize;</span><br><span class="line">        System.out.println(<span class="string">"执行 finalize 方法"</span>);</span><br><span class="line">        FinalizeDemo.Hook = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Hook = <span class="keyword">new</span> FinalizeDemo;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对象第一次拯救</span></span><br><span class="line">        Hook = <span class="keyword">null</span>;</span><br><span class="line">        System.gc;</span><br><span class="line">        <span class="comment">// 因为 finalize 方法优先级很低，所以暂停 0.5 秒以等待执行对象的 finalize 方法</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (Hook != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我还活着"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我已经死了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第二次拯救，与上面代码完全一样</span></span><br><span class="line">        Hook = <span class="keyword">null</span>;</span><br><span class="line">        System.gc;</span><br><span class="line">        <span class="comment">// 因为 finalize 方法优先级很低，所以暂停 0.5 秒以等待执行对象的 finalize 方法，但是已经执行过一次，这次不会再执行</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (Hook != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我还活着"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我已经死了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行 finalize 方法</span><br><span class="line">我还活着</span><br><span class="line">我已经死了</span><br></pre></td></tr></table></figure>

<p><font color="red">不鼓励使用 finalize 方法</font>，因为它不是 C/C++ 中的析构函数，而 Java 刚诞生时为了使 C/C++ 程序员更容易接受它所做出的妥协。它的运行代价高昂，不确定性大，无法保证各个对象调用的顺序。有些教材中描述它适合做关闭外部资源之类的工作，这完全是对这个方法用途的一种自我安慰。<font color="red">finalize 能做的工作，使用 try-finally 或者其他方法都可以做得更好的、更及时</font>。</p>
<h2 id="1-4-方法区的垃圾回收"><a href="#1-4-方法区的垃圾回收" class="headerlink" title="1.4 方法区的垃圾回收"></a>1.4 方法区的垃圾回收</h2><p>JVM 中方法区的垃圾收集主要回收两部分内容：<font color="red">废弃常量和无用的类</font>。</p>
<p><font color="red">判断是否是废弃常量</font>：没有任何对象指向该常量。例如一个字符串 “abc” 已经进入了常量池中，但是当前系统没有一个 String 对象叫做 “abc” 的，那么这个 “abc” 其实已经没有任何一个对象引用了。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p><font color="red">判断是否是无用的类（三个条件）</font>：① 该类所有实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。② 加载该类的 ClassLoader 已经被回收。③ 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>JVM 可以对满足以上三个条件的无用类进行回收，这里说的仅仅是可以，而不是和对象一样，不使用了就必然会回收。是否对类进行回收 HotSpot 虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbos:class 以及 -XX:+TraceClassLoading 和 -XX:+TraceClassUnLoading 查看类加载和卸载信息。在大量使用反射、动态代理、CGLIB 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<div class="note warning">
            <p>在此我们讨论的范围仅限于 Java 8 版本之前方法区实现为 Hotspot 虚拟机中的永久代，对于 Java 8 版本及之后的版本变更后续补充。</p>
          </div>


<h1 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2 垃圾收集算法"></a>2 垃圾收集算法</h1><p>主要的算法有三种：① 标记-清除算法，② 复制算法，③ 标记-整理算法，分代收集算法算作是对其三种的组合应用。那么各个算法到底有和优缺点？</p>
<!-- ![](垃圾收集算法.png) -->

<img src="./垃圾收集算法.png" width="600px"/>

<h2 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1  标记-清除算法"></a>2.1  标记-清除算法</h2><p>分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，注意顺序：标记-清理。</p>
<p>优点：相比较复制算法内存利用率高。<br>缺点：① 效率低，标记和清除两个过程的效率都不高；② 空间碎片多，导致后续分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h2 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h2><p>为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用内存按容量划分为大小相等的两块（内存利用率低），每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>优点：内存分配时不用考虑内存碎片问题，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br>缺点：将原有内存缩小为了一半。当对象存活率较高时会进行频繁复制操作，效率变低。</p>
<h2 id="2-3-标记-整理算法（也称标记压缩算法）"><a href="#2-3-标记-整理算法（也称标记压缩算法）" class="headerlink" title="2.3 标记-整理算法（也称标记压缩算法）"></a>2.3 标记-整理算法（也称标记压缩算法）</h2><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，注意顺序：标记-移动-清理。</p>
<p>优点：也是因为后面的移动操作，不会存在空间碎片。<br>缺点：因为多了后面的移动操作，比标记-清除算法效率还要低。</p>
<h2 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<font color="red">在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清除或者标记-整理算法来进行回收</font>。</p>
<p>在 JVM 内存使用模型，大体上就是我们的代码不停的创建对象然后分配在新生代里，但是一般很快那个对象就没人引用了，成了垃圾对象。接着一段时间过后，新生代就满了，此时就会回收掉那些垃圾对象，空出来内存空间，给后续其他的对象来使用。其实绝大多数的对象都是存活周期非常短的对象，可能被创建出来 1 毫秒之后就没人引用了，它就是垃圾对象了。所以可以想象一下，可能一次新生代垃圾回收过后，99% 的对象其实都被垃圾回收了，就 1% 的对象存活了下来，可能就是一些长期存活的对象，或者还没使用完的对象。所以<font color="red">前面理论中的复制算法的缺点：存活对象很少，未能合理分配空间，导致浪费了大量的内存空间</font>。</p>
<p>所以 HotSpot JVM 实际上做法是把新生代内存区域划分为三块，一块 Eden，两块 Survivor，其中 Eden 区占 80% 内存空间，每一块 Survivor 区各占 10% 内存空间。比例为 8:1，由参数 -XX:SurvivorRatio 控制。<font color="red">具体算法执行过程</font>：刚开始对象都是分配在 Eden 区内，如果 Eden 区满了，就会触发垃圾回收，此时就会把 Eden 区中的存活对象都一次性转移到一块空着的 Survivor 区。接着 Eden 区就会被清空，然后再次分配新对象到 Eden 区里，Eden 区和一块 Survivor 区里是有对象的，其中 Survivor 区里放的是上一次 Young GC 后存活的对象。如果下次再次 Eden 区满，那么再次触发 Young GC，就会把 Eden 区和放着上一次 Young GC 后存活对象的 Survivor 区内的存活对象，转移到另外一块 Survivor 区去。接着新对象继续分配在 Eden 区和另外那块开始被使用的 Survivor 区，然后始终保持一块 Survivor 区是空着的，就这样一直循环使用这三块内存区域。</p>
<img src="分代收集算法.png" width="400px"/>

<p>这么做<font color="red">最大的好处</font>，就是只有 10% 的内存空间是被闲置的，90% 的内存都被使用上了，无论是垃圾回收的性能，内存碎片的控制，还是说内存使用的效率，都非常的好。</p>
<p><font color="red">老年代的标记-整理算法的速度至少比新生代的复制算法的速度慢 10 倍</font>。如果系统频繁出现老年代的 Old GC 垃圾回收，会导致系统性能被严重影响，出现频繁卡顿的情况。</p>
<div class="note warning">
            <p>所谓 JVM 优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</p>
          </div>

<h1 id="3-HosSpot-垃圾收集器"><a href="#3-HosSpot-垃圾收集器" class="headerlink" title="3 HosSpot 垃圾收集器"></a>3 HosSpot 垃圾收集器</h1><p>垃圾收集算法为内存回收的方法论，接下来要详述的垃圾收集器就是内存回收的具体实现。不同厂商、不同版本的虚拟机所提供的垃圾收集器都不尽相同，并且一般都会提供参数供用户根据自己的应用特点和要求自由组合出各个年代所使用的收集器。这里主要讨论下 HotSpot 虚拟机下的垃圾收集器：</p>
<img src="HotSpot垃圾收集器.png" width="600px"/>


<p>切记：没有十全十美的的收集器，只有最合适的收集器。</p>
<p><font color="red">JVM 的痛点：Stop the World</font></p>
<p>在垃圾收集的时候，为了尽可能让垃圾收集器专心致志的干活，不能随便让我们写的 Java 系统继续创建对象，此时 JVM 会进入 Stop the World 状态。也就是说会直接停止我们写的 Java 系统的所有工作线程，让我们写的代码不再运行！专心垃圾收集。</p>
<p>如果是 Young GC，暂停所有的工作线程，导致请求过来到响应返回，可能需要等待几百毫秒。那么当内存分配不合理，导致对象频繁进入老年代，进而产生 Old GC，而 Old GC 是最慢的，有时候可能一次回收要进行几秒钟，甚至几十秒，极端情况几分钟都是有可能的。</p>
<p>所以说，无论是 Young GC 还是 Old GC，都尽量不要让频率过高，也避免持续时间过长，避免影响系统正常运行，这也是使用 JVM 过程中一个最需要优化的地方，也是最大的一个痛点。</p>
<p><font color="red">不同垃圾收集器 Stop the World 所对 JVM 性能造成的影响不同</font></p>
<p>对于新生代的 Serial 垃圾收集器就是用一个线程进行垃圾对象收集，然后此时暂停系统工作线程，所以一般我们在服务器程序中很少用这种方式。常用的新生代垃圾收集器是 ParNew ，它针对服务器一般都是多核 CPU 做了优化，他是支持多线程个垃圾回收的，可以大幅度提升回收的性能，缩短回收的时间。CMS 使用一套独特的机制尽可能的在垃圾回收的过程中减少 Stop the World 的时间，避免长时间卡死我们的系统。</p>
<p>接下来分析下各个垃圾收集器的运行机制。</p>
<h2 id="3-1-Serial-ParNew-与-Serial-Old"><a href="#3-1-Serial-ParNew-与-Serial-Old" class="headerlink" title="3.1 Serial/ParNew 与 Serial Old"></a>3.1 Serial/ParNew 与 Serial Old</h2><p>Serial 与 Serial Old 收集器运行示意图：</p>
<img src="Serial与ParNew垃圾收集器运行示意图.png" width="580px"/>

<p>需要说明的是：</p>
<ol>
<li>新生代的 ParNew 垃圾收集器主打的就是多线程垃圾回收机制，另外一种 Serial 垃圾收集器主打的是单线程垃圾回收，他们俩都是回收新生代的，唯一的区别就是单线程和多线程的区别，垃圾回收算法是完全一样的。</li>
<li>Serial 与 Serial Old 收集器基本已经不怎么使用。</li>
<li>在没有 G1 垃圾收集器之前，通常采用 ParNew + CMS 垃圾收集器。即使现在已经有了 G1，很多线上系统还是用的 ParNew 垃圾收集器。</li>
<li>ParNew 垃圾收集器默认情况下的线程数量是与 CPU 的核数一样的。一般不要随意修改，但是也可以通过 -XX:ParallelGCThreads 参数调整。</li>
</ol>
<h2 id="3-2-Parallel-Scavenge"><a href="#3-2-Parallel-Scavenge" class="headerlink" title="3.2 Parallel Scavenge"></a>3.2 Parallel Scavenge</h2><p>Parallel Scavenge 收集器是新生代收集器，使用的复制算法，又是多线程收集器…看上去和 ParNew 都一样，那它有什么特别之处吗？</p>
<p>第一：与其他收集器关注点不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 <font color="red">Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量</font>。此处的 吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。Parallel Scavenge 收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis 参数，以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数。</p>
<p>第二：<font color="red">自适应调节策略</font>，Parallel Scavenge 收集器使用参数 -XX:+UseAdaptiveSizePolicy 可以开启自适应调节策略，所谓自适应调节策略，是指用户无需设置新生代大小、Eden 与 Survivor 区的比例、晋升老年代对象年龄等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<p>使用 Parallel Scavenge 收集器：</p>
<ol>
<li>设置基本的内存数据，比如 -Xmx 设置最大堆；</li>
<li>设置 MaxGCPauseMillis 参数（更关注最大停顿时间）或 GCTimeRatio 参数（更关注吞吐量）给虚拟机设立一个优化目标；</li>
<li>设置 -XX:+UseAdaptiveSizePolicy 参数，开启自适应调节策略。</li>
</ol>
<p>详细内容参见：<a href="">《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》（第二版）</a> 3.5.5 Parallel Scavenge 收集器章节内容。</p>
<h2 id="3-3-Parallel-Old"><a href="#3-3-Parallel-Old" class="headerlink" title="3.3 Parallel Old"></a>3.3 Parallel Old</h2><p>在 Parallel Old 之前，新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。原因是，如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old 收集器别无选择。由于老年代 Serial Old 收集器在性能上的拖累，使用 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果。</p>
<p>直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了名副其实的应用组合。</p>
<p>Parallel Scavenge/Parallel Old 收集器运行示意图：</p>
<img src="ParallelScavenge与ParallelOld收集器运行示意图.png" width="540px"/>

<h2 id="3-4-CMS【重点】"><a href="#3-4-CMS【重点】" class="headerlink" title="3.4 CMS【重点】"></a>3.4 CMS【重点】</h2><p>CMS 采用标记-清除算法，所以会产生大量的内存碎片， 采用的是垃圾收集线程与系统工作线程尽量同时执行的模式来处理。为什么叫尽量呢？因为在初始标记阶段和重新标记阶段是无法并行运行的。</p>
<p>CMS 收集器运行示意图：</p>
<img src="CMS垃圾收集器运行示意图.png" width="650px"/>

<h3 id="①-执行阶段"><a href="#①-执行阶段" class="headerlink" title="① 执行阶段"></a>① 执行阶段</h3><p><font color="red">第一阶段：初始标记（很快）</font></p>
<p>标记出所有 GC Roots 直接引用对象，初始标记阶段会造成 Stop the World，暂停一切工作线程，但是影响不大，因为速度非常，仅仅是标记 GC Roots 直接引用对象而已。</p>
<p>比如下面的代码，在初始标记阶段，仅仅会通过 replicaManager 这个类的静态变量代表的 GC Roots，去标记出来他直接引用的 ReplicaManager 对象，这就是初始标记的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kafka</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReplicaManager replicaManager = <span class="keyword">new</span> ReplicaManager();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplicaManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReplicaFetcher replicaFetcher = <span class="keyword">new</span> ReplicaFetcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">第二阶段：并发标记（标记最耗时，但是对系统程序影响不大）</font></p>
<p>这个阶段会让系统线程可以随意创建对象，继续运行，在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象。在整这个过程中，垃圾收集线程会尽可能的对已有对象进行 GC Roots 追踪。</p>
<p><font color="red">何为 GC Roots 追踪？</font>就是看看老年代里的对象被谁引用了？比如代码中 ReplicaFetcher  的全部老年代对象被 ReplicaManager 对象的实例变量引用了，接着会看，ReplicaManager 对象被谁引用了？会发现被 Kafka 类的静态变量引用了。对于老年代对象进行 GC Roots 追踪需要追踪所有对象是否从根源上被 GC Roots 引用，所以这个过程是是最耗时的。</p>
<p><font color="red">第三阶段：重新标记（很快）</font></p>
<p>注意，并发标记只是尽可能的对已有对象进行 GC Roots 追踪，所以第二阶段的结束之后，绝对会有很多存活对象和垃圾对象。因此，进入第三阶段重新标记垃圾对象。</p>
<p>重新标记也会造成 Stop the World，暂停一切工作线程，重新标记速度很快，其实就是对第二阶段中被系统程序变动过的少数对象进行标记，所以速度很快。</p>
<p>第三阶段结束，系统重新恢复运行，进入第四阶段。</p>
<p><font color="red">第四阶段：并发清除（清除很耗时，但是对系统程序影响不大）</font></p>
<p>该阶段为了清除第三阶段的垃圾对象，与系统程序并发运行。因为要对对象进行清除操作，所以很耗时。</p>
<h3 id="②-性能分析"><a href="#②-性能分析" class="headerlink" title="② 性能分析"></a>② 性能分析</h3><p>可以看到耗时的第二、四阶段，系统程序都是并发运行的，并且 Stop the World 的第一、三阶段只是进行简单的标记，速度很快，所以对性能影响不大。</p>
<h3 id="③-三大问题"><a href="#③-三大问题" class="headerlink" title="③ 三大问题"></a>③ 三大问题</h3><p><font color="red">问题 1：CPU 资源紧张</font></p>
<p>在 CMS 垃圾收集器与系统程序并发阶段，CMS 垃圾收集器虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。</p>
<p>CMS 默认启动的回收线程数是（CPU 数量+3）/4，也就是当 CPU 在 4 个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如 2 个）时，CMS 对用户程序的影响就可能变得很大，如果本来CPU 负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。</p>
<p><font color="red">问题 2：Concurrent Mode Failure 问题</font></p>
<p>在并发清除阶段，系统一直在运行，可能会随着系统运行使得一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象被称为“浮动对象”。由于 CMS 在这个阶段只不过是回收之前标记好的垃圾对象，所以对这种“浮动对象”是不会回收的，只能等到下次 GC 才回收它们。所以为了保证 CMS 在执行垃圾回收期间，还有一定的空间使得一些对象可以进入老年代，一般会预留一些空间。</p>
<p>CMS 垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就自动执行 GC。 -XX:CMSInitiatingOccupancyFaction 参数可以用来设置老年代占用多少比例的时候触发 CMS 垃圾回收，JDK 1.6 里面默认的值是 92%。 也就是说，老年代占用了 92% 空间了，就自动进行 CMS 垃圾回收，预留 8% 的空间给并发回收期间，系统程序把一些新对象放入老年代中。</p>
<p>那么如果 CMS 垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何？ 这个时候，会发生 Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。</p>
<p>此时就会自动用 Serial Old 垃圾回收器替代 CMS，就是直接强行把系统程序 Stop the World，重新进行长时间的 GC Roots 追踪，标记出来全部垃圾对象，不允许新的对象产生。 然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。所以在生产实践中，这个自动触发 CMS 垃圾回收的比例需要合理优化一下，避免 Concurrent Mode Failure 问题。</p>
<p><font color="red">问题 3：内存碎片问题</font></p>
<p>CMS 采用标记-清除算法，这就意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 Old GC。</p>
<p>为了解决这个问题，CMS 收集器提供了一个 -XX：+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 Old GC 之后要再次进行 Stop the World，停止工作线程，开启内存碎片的合并整理，由此可见内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</p>
<p>虚拟机设计者还提供了另外一个参数 -XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次 Old GC 后再执行一次内存整理的工作，默认值为 0，表示每次 Old GC 后都进行一次内存整理。</p>
<h2 id="3-5-G1【TODO】"><a href="#3-5-G1【TODO】" class="headerlink" title="3.5 G1【TODO】"></a>3.5 G1【TODO】</h2><h1 id="4-内存分配策略"><a href="#4-内存分配策略" class="headerlink" title="4 内存分配策略"></a>4 内存分配策略</h1><p>经典的 JVM 内存分配流程图：</p>
<p><img src="JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/28/JVM-01-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/28/JVM-01-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" class="post-title-link" itemprop="url">JVM-01-内存区域</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-28 23:40:23" itemprop="dateCreated datePublished" datetime="2019-10-28T23:40:23+08:00">2019-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-19 17:18:09" itemprop="dateModified" datetime="2019-11-19T17:18:09+08:00">2019-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1 运行时数据区域"></a>1 运行时数据区域</h1><!-- ![](./运行时数据区域.png) -->

<img src="./运行时数据区域.png" width="600px"/>

<div class="note warning">
            <p>① <font color=red>其实以上区域规划只是一个规范而已，至于各个厂商的具体实现就有可能不同了</font>，比如对于 HotSpot 虚拟机并不区分虚拟机栈和本地方法栈。<br>② <font color=red>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域</font>。其他区域都有可能抛出 OutOfMemoryError。<br>③ 虚拟机栈和本地方法栈不仅可能抛出 OutOfMemoryError，还有可能会抛出 StackOverflowError。</p>
          </div>

<h2 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h2><p>可以看作是当前线程所执行的字节码的行号指示器，指向下一条要执行的指令。如果线程正在执行的是一个 Java 方法，这个计数器值为正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空。</p>
<h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><p>描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧（栈帧是方法运行时的基础数据结构）在虚拟机栈中入栈到出栈的过程。</p>
<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</p>
<!-- > 关于局部变量表、操作数栈、动态链接、方法出口等信息参见：[深究 JVM-05：虚拟机字节码执行引擎]() -->

<h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><p>虚拟机栈与本地方法栈的区别：① 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务。② 本地方法栈则是为虚拟机使用到的 Native 方法服务。</p>
<p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（<font color=red>譬如 Sun HotSpot 虚拟机</font>）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h2 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h2><p>Java 虚拟机规范中的描述：所有的<font color=red>对象实例</font>以及<font color=red>数组</font>都要在堆上分配，但是随着 <font color=red>JIT 编译器</font>的发展与<font color=red>逃逸分析技术</font>逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，<font color=red>所有对象分配在堆上也渐渐变得不是那么“绝对”了</font>。</p>
<p>由于现在收集器基本都是采用的<font color=red>分代收集算法</font>，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等（默认 Eden : From Survivor : To Survivor = 8:1:1）。<font color=red>如果从内存分配的角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）</font>。不论如何划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。</p>
<!-- ![](堆内存划分.png) -->

<div class="note warning">
            <p>扩展一：为什么要分成新生代和老年代？因为跟垃圾回收有关，见：<a href="">深究 JVM-02：垃圾收集器与内存分配策略</a><br>扩展二：<a href="https://dsxwjhf.iteye.com/blog/2201687" target="_blank" rel="noopener">为何需要两个 Survivor 空间？</a></p>
          </div>

<p>Java 堆可以处于<font color=red>物理上不连续</font>的内存空间中，只要<font color=red>逻辑上是连续</font>的即可（就像我们的磁盘空间一样）。在实现时，既可以实现成<font color=red>固定大小</font>的，也可以是<font color=red>可扩展</font>的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</p>
<h2 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <font color=red>Non-Heap</font>（非堆），目的应该是与 Java 堆区分开来。</p>
<p><font color=red>方法区与永久代（Permanent Generation）本质上两者并不等价。仅仅是因为 HotSpot 虚拟机的设计团队选择把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已（将方法区理解为一套规范，只是 HotSpot 虚拟机用永久代去实现这套规范而已）</font>。对于其他虚拟机（如 BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。<font color=red>Java 7 中已经将原本放在永久代的字符串常量池移除</font>。</p>
<p>方法区同堆区一样不需要连续的内存，可以选择固定大小或者可扩展。</p>
<p>方法区可以选择不实现垃圾收集。垃圾收集在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在 Sun 公司的 BUG 列表中，曾出现过的若干个严重的BUG就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>
<p><font color=red>运行时常量池</font>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（见：<a href="">深究 JVM-04-类文件结构</a>），用于存放编译期生成的各种<font color=red>字面量和符号引用</font>，这部分内容将在<font color=red>类加载后</font>存放到方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，<font color=red>除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</font>。运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备<font color=red>动态性</font>，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，<font color=red>运行期间也可能将新的常量放入池中</font>，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。既然运行时常量池是方法区的一部分，无法申请到内存时会抛出 OutOfMemoryError 异常。</p>
<div class="note warning">
            <p>在 HotSpot 虚拟机中 Java 8 之前使用永久代来实现方法区，在 Java 8 版本改为使用<font color="red">元空间（MetaSpace）</font>，之所以替换的原因是因为在 Java 8 之前虚拟机会根据 -XX:PermSize 以及 -XX:MaxPermSize 参数配置的大小来分配一块连续的内存块，但是随着动态类加载的情况越来越多，这块内存变得不可控，-XX:PermSize 以及 -XX:MaxPermSize 参数到底设置多大才是最合适的是每个开发者要考虑的问题，如果设置太小，系统运行过程中就容易出现内存溢出，设置大了就总感觉浪费。所以元空间出现了，它出现的本意就是希望内存的管理不再受限制，也不用关注元数据这块的 OutOfMemoryError 问题，尽管从目前看来也并没有完美解决这个问题。</p><p>更多关于方法区、永久代、元空间的知识点请参考以下资料：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html" target="_blank" rel="noopener">官方文档：Class Metadata</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html" target="_blank" rel="noopener">官方文档：Understand the OutOfMemoryError Exception</a></li><li><a href="https://www.jianshu.com/p/b448c21d2e71" target="_blank" rel="noopener">阿飞的博客：JVM 参数 MetaspaceSize 的误解</a></li><li><a href="http://lovestblog.cn/blog/2016/10/29/metaspace/" target="_blank" rel="noopener">你假笨：JVM 源码分析之 Metaspace 解密</a></li></ul>
          </div>

<h2 id="1-6-直接内存"><a href="#1-6-直接内存" class="headerlink" title="1.6 直接内存"></a>1.6 直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常。在 JDK1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道与缓冲区的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Navtive 堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不受 Java 堆大小的限制，但是，既然是内存，还是受本机总内存大小以及处理器寻址空间的限制。</p>
<div class="note warning">
            <p>扩展：<a href="https://juejin.im/entry/5b558d62e51d4519596b95c5" target="_blank" rel="noopener">Java NIO 分析(10): JVM 堆外内存利用改进: DirectByteBuffer 详解</a></p>
          </div>

<h1 id="2-HopSpot-虚拟机与堆中的对象"><a href="#2-HopSpot-虚拟机与堆中的对象" class="headerlink" title="2 HopSpot 虚拟机与堆中的对象"></a>2 HopSpot 虚拟机与堆中的对象</h1><p>在此以常用的虚拟机 Hotspot 和常用的内存区域 Java 堆为例，深入探讨 Hotspot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h2 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h2><p>语言层面，创建对象（例如克隆、反序列化）通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建又是怎样的一个过程呢？<font color="red">①</font> 虚拟机遇到一条 new 指令时，首先会去检查该指令的参数能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、初始化过，如果没有，则必须先执行相应的类加载过程。<font color="red">②</font> 在类加载检查完成后，虚拟机将为新对象分配内存空间，且对象所需内存空间大小在其完成类加载检查后即可确定，该过程其实就是在堆中划分一小部分的确定大小的空间，用于存储对象信息。</p>
<h3 id="2-1-1-虚拟机为新对象分配内存的分配方式"><a href="#2-1-1-虚拟机为新对象分配内存的分配方式" class="headerlink" title="2.1.1 虚拟机为新对象分配内存的分配方式"></a>2.1.1 虚拟机为新对象分配内存的分配方式</h3><p><font color="red">指针碰撞</font>：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称 为“指针碰撞”。</p>
<p><font color="red">空闲列表</font>：如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p>
<p><font color="red">选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</font>。因此，在使用 Serial、ParNew 等带有 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p>
<h3 id="2-1-2-并发分配内存两种方案"><a href="#2-1-2-并发分配内存两种方案" class="headerlink" title="2.1.2 并发分配内存两种方案"></a>2.1.2 并发分配内存两种方案</h3><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针分配内存的情况。那么如何应对并发分配内存呢？方案有两种。</p>
<p><font color="red">方案一</font>：对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS（Compare And Switch）配上失败重试的方式保证更新操作的原子性。</p>
<p><font color="red">方案二</font>：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB），哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过参数 -XX:+/-UseTLAB 参数来设定。</p>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都<font color="red">初始化为零值</font>（不包括对象头），如果使用 TLAB，这一工作过程也可以提前至 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来，虚拟机要对<font color="red">对象进行必要的设置</font>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头中，根据虚拟机当前的运行状态不同，如是否启用偏向锁或轻量级锁，对象头会有不同的设置方式。详细介绍参见：<a href="">2.2 对象的内存布局</a>。</p>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始， &lt;init&gt; 方法还没有执行，&lt;init&gt; 方法是在一个类进行对象实例化时调用的，所有字段都还为零值。所以，一般来说，<font color="red">执行 new 指令之后会接着执行 &lt;init&gt; 方法</font>，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<p>总结下虚拟机的创建过程：</p>
<!-- ![](./虚拟机创建对象.png) -->
<img src="./虚拟机创建对象.png" width="700px"/>

<h2 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h2><p>对象在内存中存储的布局区域：</p>
<img src="./对象在内存中存储的布局.png" width="1000px"/>
<!-- ![](对象在内存中存储的布局.png) -->

<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类中继承下来的，还是在子类中定义的，都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数（FieldAllocationStyle）和字段在 Java 源码中定义顺序的影响。Hotspot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，可见，相同宽度的字段会被分配在一起。在满足这个前提条件下，父类中定义的变量会出现在子类之前。如果 CompactField 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<h2 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h2><p>建立对象就是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用<font color="red">句柄</font>和<font color="red">直接指针</font>两种。</p>
<h3 id="2-3-1-句柄访问方式"><a href="#2-3-1-句柄访问方式" class="headerlink" title="2.3.1 句柄访问方式"></a>2.3.1 句柄访问方式</h3><p>句柄访问会在 Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<!-- ![](对象定位-通过句柄访问对象.png) -->

<img src="./对象定位-通过句柄访问对象.png" width="600px"/>

<p>优势：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。<br>缺点：由于多了一次指针定位对象实例数据的开销，所以速度相比较慢。</p>
<h3 id="2-3-2-直接指针方式"><a href="#2-3-2-直接指针方式" class="headerlink" title="2.3.2 直接指针方式"></a>2.3.2 直接指针方式</h3><p>直接指针访问方式在 Java 堆对象中存放了一个指向对象类型数据的指针，<font color="red">Sun HotSpot 采用的就是这种方式进行对象访问的，在 HotSpot 中，这个指针会被存放在对象头中</font>。</p>
<!-- ![](对象定位-通过直接指针访问对象.png) -->

<img src="./对象定位-通过直接指针访问对象.png" width="600px"/>

<p>优势：减少了一次指针定位对象实例数据的开销，速度更快。<br>缺点：由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可怕的执行成本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/28/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-ThreadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王鹏博">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Westboy'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/28/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-ThreadLocal/" class="post-title-link" itemprop="url">并发基础-ThreadLocal</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-28 21:35:46" itemprop="dateCreated datePublished" datetime="2019-10-28T21:35:46+08:00">2019-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-30 09:23:05" itemprop="dateModified" datetime="2019-10-30T09:23:05+08:00">2019-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">并发基础</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-初识-ThreadLocal"><a href="#1-初识-ThreadLocal" class="headerlink" title="1 初识 ThreadLocal"></a>1 初识 ThreadLocal</h1><div class="note info">
            <p>实现好的并发是一件困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。什么是<font color=red>线程封闭</font>呢？ 就是把对象封装到一个线程里，只有这一个线程能看到此对象。那么这个对象就算不是线程安全的也不会出现任何安全问题。Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal 类。摘自《Java 并发编程实战》3.3 节线程封闭，见 P42。</p>
          </div>


<p>ThreadLocal 提供了 get 与 set 等方法，这些方法为每个使用该变量的线程都存有一份独立的副本。因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个 Connection 对象。由于 JDBC 的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个对象都会拥有属于自己的连接，如所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = ThreadLocal.withInitial(() -&gt; DriverManager.getConnection(DB_URL));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当某个线程初次调用 ThreadLocal#get 方法时，就会获取 withInitial 初始化后的初始值。从概念上看，你可以将 ThreadLocal 视为包含了 Map&lt;Thread,T&gt; 对象，其中保存了特定于该线程的值，但 ThreadLocal 的实现并非如此。<font color=red>这些特定于线程的值保存在 Thread 对象中，当线程终止后，这些值会作为垃圾回收</font>。</p>
<p>ThreadLocal 为解决多线程程序的并发问题提供了一种<font color=red>新的思路</font>，即躲避并发问题。因此 ThreadLocal 无法解决共享变量的更新问题。由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！！！</p>
<p>ThreaLocal 使用示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程一</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    threadLocal1.set(i);</span><br><span class="line">                    threadLocal2.set(i * <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">":"</span> + threadLocal1.get() + <span class="string">":"</span> + threadLocal2.get());</span><br><span class="line">                    sleep(<span class="number">200</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocal1.remove();</span><br><span class="line">                threadLocal2.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread-1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程二</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() </span><br><span class="line">                        + <span class="string">":"</span> + threadLocal1.get() + <span class="string">":"</span> + threadLocal2.get());</span><br><span class="line">                    sleep(<span class="number">200</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                threadLocal1.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread-2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程中部分打印内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-1:11:22</span><br><span class="line">Thread-2:null:null</span><br><span class="line">Thread-1:12:24</span><br><span class="line">Thread-2:null:null</span><br><span class="line">Thread-1:13:26</span><br><span class="line">Thread-2:null:null</span><br></pre></td></tr></table></figure>

<p>从运行的结果我们可以看到 Thread-1 进行 set 值对 Thread-2 并没有任何影响！</p>
<p>结合以上示例，通过以下两个关系深深体会下它们之间的关系。</p>
<!-- ![](./示例关系图-2.png) -->

<img src="./示例关系图-2.png" width="700px"/>


<h1 id="2-ThreadLocal-源码分析"><a href="#2-ThreadLocal-源码分析" class="headerlink" title="2 ThreadLocal 源码分析"></a>2 ThreadLocal 源码分析</h1><p>要理解 ThreadLocal 的实现原理，必须理解以下三个类：</p>
<ul>
<li><font color="red">Thread</font></li>
<li><font color="red">ThreadLocal</font> — Thread 中维护的 ThreadLocalMap 类型的实例变量</li>
<li><font color="red">ThreadLocalMap</font> — ThreadLocal 的静态内部类</li>
</ul>
<p>三者的关系图见下：</p>
<!-- ![](并发编程之-05-深究ThreadLocal/Thread、ThreadLocal和ThreadLocalMap关系图.png) -->

<p>在 Thread 类下维护这一个类型为 ThreadLocalMap 类型的成员变量 threadLocals，ThreadLocalMap 为 ThreadLocal 下定义的静态内部类，是一个 Map 结构，key 是 ThreadLocal 类型，value 为 Object 类型。</p>
<p>ThreadLocalMap 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt;&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ThreadLocalMap 的 Entry 继承了 WeakReference。那么为什么要继承 WeakReference 类型？见后续内容。</p>
<p>那么，ThreadLocal 是如何工作的呢？先了解一下 ThreadLocal 类提供的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-get-方法"><a href="#2-1-get-方法" class="headerlink" title="2.1 get 方法"></a>2.1 get 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的 ThreadLocalMap  对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果 map 不是 null，将 ThreadlLocal 对象作为 key 获取对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">// 如果该值存在，则返回该值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果上面的逻辑没有取到值，则从 initialValue 方法中取值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-setInitialValue-方法"><a href="#2-2-setInitialValue-方法" class="headerlink" title="2.2 setInitialValue 方法"></a>2.2 setInitialValue 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setInitialValue 方法为模板方法，其中 initialValue 需要初始化时进行重写，initialValue 默认返回 null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前线程 ThreadLocalMap 为空创建 ThreadLocalMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-set-方法"><a href="#2-3-set-方法" class="headerlink" title="2.3 set 方法"></a>2.3 set 方法</h2><p>set 方法设置的 key 固定为当前线程的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的成员变量 threadLocals 的值（类型为 ThreadLocal.ThreadLocalMap）</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 核心操作</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前线程 threadLocals 属性为 null 时，需要新建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前线程 threadLocals 属性不为 null 时，需要更新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value associated with key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 计算数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// key 相等，覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key 为 null，用新的 value 覆盖，同时清理 key=null 的实例，防止内存泄漏</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新的节点</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 再次清理 key=null 的实例，防止内存泄漏，判断是否超过阈值，如果超过需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 map.set(this, value) 方法中除了存储元素之外，<font color="red">还有一个很重要的作用</font>，就是 replaceStaleEntry 和 cleanSomeSlots 方法，这两个方法可以清除掉 key=null 的实例，防止内存泄漏（后续会详细讲述）。</p>
<p>在该方法中还有一个变量很重要：threadLocalHashCode，该变量为 ThreadLocal 的成员变量，定义为：private final int threadLocalHashCode = nextHashCode(); 从名字上面我们可以看出 threadLocalHashCode 应该是 ThreadLocal 实例变量的散列值，定义为 final，表示 ThreadLocal 实例变量一旦创建其散列值就已经确定了，生成过程则是调用 nextHashCode 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nextHashCode 表示分配下一个 ThreadLocal 实例的 threadLocalHashCode 的值，HASH_INCREMENT 则表示分配两个 ThradLocal 实例的 threadLocalHashCode 的增量。</p>
<h2 id="2-4-remove-方法"><a href="#2-4-remove-方法" class="headerlink" title="2.4 remove 方法"></a>2.4 remove 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-内存泄漏问题"><a href="#3-内存泄漏问题" class="headerlink" title="3 内存泄漏问题"></a>3 内存泄漏问题</h1><p>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，<font color="red">弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</font>ThreadLocal 为什么要使用弱引用？原因很简单：有助于垃圾收集器回收。</p>
<p>结合之前的示例中的关系图：</p>
<img src="./示例关系图-2.png" width="650px"/>

<p>当仅仅只有 ThreadLocalMap 中的 Entry 的 key 指向 ThreadLocal 变量的时候，此时 key 没有被外部强引用，ThreadLocal 就会进行回收。</p>
<p>ThreadLocal 被垃圾回收后，在 ThreadLocalMap 里对应的 Entry 的 key 值会变成 null，但是 Entry 是强引用，那么 Entry 里面存储的 Object，并没有办法进行回收，所以 ThreadLocalMap 做了一些额外的回收工作。</p>
<p>ThreadLocal 在 get、set、remove 方法方法中执行的过程中都会对 key 为 null 的键值对进行清理，具体的执行清理方法是 expungeStaleEntry，源码见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>; <span class="comment">//</span></span><br><span class="line">            tab[i] = <span class="keyword">null</span>; 	<span class="comment">//</span></span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果一个线程运行周期较长，而且将一个大对象放入 ThreadLocalMap 后便不再调用 set、get、remove 方法，可能会导致内存泄漏。这个问题确实存在，只能依靠程序员在完成 ThreadLocal 的使用后要<font color=red>养成手动调用 remove 的习惯，从而避免内存泄漏</font>。</p>
<!-- 内存泄漏的深入理解：TODO -->

<p>建议：<font color=red>ThreadLocal 变量使用 static 修饰</font>的一个好处是由于 ThreadLocal 有强引用在，那么在 ThreadLocalMap 里对应的 Entry 的键会永远存在，那么执行 remove 的时候就可以正确进行定位到并且删除。</p>
<p>最佳实践做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;?&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-扩展-ThreadLocalRandom"><a href="#4-扩展-ThreadLocalRandom" class="headerlink" title="4 扩展 ThreadLocalRandom"></a>4 扩展 ThreadLocalRandom</h1><p>ThreadLocalRandom 类是 JDK7 在 JUC 包下新增的随机数生成器，它解决了 Random 类在并发场景下多个线程竞争内部唯一的原子性种子变量而导致大量线程自旋重试的不足的问题。</p>
<p>Random 类的底层实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="comment">// ① 获取当前原子变量种子的值</span></span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">// ② 根据当前种子值计算新的种子</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        <span class="comment">// ③ 使用 CAS 操作，使用新的种子去更新旧的种子</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="comment">// ④ 使用固定算法根据新的种子计算随机数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发场景下可能多个线程同时执行到 ① 处时，可能多个线程都拿到的当前种子的值是同一个，然后执行步骤 ② 时计算的新种子也都是一样的，但是步骤 ③ 的 CAS 操作会保证只有一个线程可以更新旧的种子为新的，失败的线程会通过循环重新获取更新后的种子作为当前种子去计算新的种子。因此会造成大量线程进行自旋重试，这会降低并发性能，所以 ThreadLocalRandom 应运而生。</p>
<p>ThreadLocalRandom 示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandomTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取当前线程的随机数生成器</span></span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalRandom 使用 ThreadLocal 的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争。</p>
<h1 id="5-扩展-InheritableThreadLocal"><a href="#5-扩展-InheritableThreadLocal" class="headerlink" title="5 扩展 InheritableThreadLocal"></a>5 扩展 InheritableThreadLocal</h1><blockquote>
<p><a href="https://blog.csdn.net/hewenbo111/article/details/80487252" target="_blank" rel="noopener">InheritableThreadLocal —— 父线程传递本地变量到子线程的解决方式及分析</a></p>
</blockquote>
<h1 id="6-扩展-Netty-的-FastThreadLocal"><a href="#6-扩展-Netty-的-FastThreadLocal" class="headerlink" title="6 扩展 Netty 的 FastThreadLocal"></a>6 扩展 Netty 的 FastThreadLocal</h1><blockquote>
<p><a href="https://www.jianshu.com/p/3fc2fbac4bb7" target="_blank" rel="noopener">Netty 高性能之道 FastThreadLocal 源码分析（快且安全）</a></p>
</blockquote>
<h1 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7 参考资料"></a>7 参考资料</h1><p><a href="https://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">Java 并发编程：深入剖析 ThreadLocal</a><br><a href="http://www.cnblogs.com/fengzheng/p/8690253.html" target="_blank" rel="noopener">ThreadLocal 原理和使用场景分析</a><br><a href="https://www.cnblogs.com/dennyzhangdd/p/7978455.html" target="_blank" rel="noopener">ThreadLocal 终极源码剖析一篇足矣！</a><br><a href="https://www.cnblogs.com/micrari/p/6790229.html" target="_blank" rel="noopener">ThreadLocal 源码解读</a><br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247485907&idx=1&sn=bb4f5b32ae351abf385540bffee8b0ef&chksm=cef5fa65f98273731b62c55d0dddf6072d4802705259a4858a2688a2d04547dd51f208c10bca&mpshare=1&scene=1&srcid=0625ReyxRaiLvssJnb82buXR&key=c4663b7b314f3cd83378190878df2709d292f81c4e4b8e236c99457d571323519102f30483893abb5e1fa98ef2a2352e53b2cb29e9eb5cd9f0f935c63af2a1c7360ec0d35b0e6e839dd24cde97a947de&ascene=1&uin=MTk1OTUwMzYyMQ%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=QGf8TWxJmxNuMBJMbdBn0qv%2FniKw1Z2mn7%2BOEl3ti349wffPAFROCKPhE0I3AC1j" target="_blank" rel="noopener">手撕面试题 ThreadLocal</a><br><a href="https://blog.csdn.net/hanchao5272/article/details/79691746" target="_blank" rel="noopener">Java 并发 29：ThreadLocalRandom 学习笔记-随机数的三种使用方法</a><br><a href="http://ifeve.com/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%ADthreadlocalrandom%E7%B1%BB%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/" target="_blank" rel="noopener">并发包中 ThreadLocalRandom 原理剖析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="王鹏博"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">王鹏博</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王鹏博</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.2"></script><script src="/js/motion.js?v=7.4.2"></script>
<script src="/js/schemes/pisces.js?v=7.4.2"></script>
<script src="/js/next-boot.js?v=7.4.2"></script>



  


















  

  

  

</body>
</html>
